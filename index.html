<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>2D Particle Collider</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      color: #fff;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    canvas {
      display: block;
      background: #000;
    }
    #controls {
      position: absolute;
      top: 15px;
      left: 15px;
      z-index: 10;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      background: rgba(20, 20, 30, 0.85);
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(5px);
      border: 1px solid rgba(100, 150, 255, 0.2);
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      background: linear-gradient(145deg, #1e3a8a, #2563eb);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }
    button:hover {
      background: linear-gradient(145deg, #2563eb, #3b82f6);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
    }
    button:active {
      transform: translateY(1px);
    }
    #resetBtn {
      background: linear-gradient(145deg, #1f2937, #374151);
    }
    #resetBtn:hover {
      background: linear-gradient(145deg, #374151, #4b5563);
    }
    label {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #e2e8f0;
      font-size: 14px;
      user-select: none;
    }
    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(240, 240, 240, 0.9);
      padding: 8px 15px;
      border-radius: 20px;
      position: relative;
      height: 36px;
    }
    .slider-label {
      color: #333;
      font-weight: 500;
      white-space: nowrap;
    }
    input[type="range"] {
      -webkit-appearance: none;
      width: 120px;
      height: 6px;
      border-radius: 3px;
      background: #ddd;
      outline: none;
      position: relative;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #10b981;
      cursor: pointer;
      box-shadow: 0 0 5px rgba(16, 185, 129, 0.5);
    }
    input[type="range"]::-webkit-slider-runnable-track {
      background: linear-gradient(to right, #10b981 0%, #10b981 var(--value, 0%), #ddd var(--value, 0%), #ddd 100%);
      border-radius: 3px;
      height: 6px;
    }
    input[type="number"] {
      width: 60px;
      padding: 5px;
      background: rgba(30, 30, 50, 0.8);
      border: 1px solid #4f46e5;
      border-radius: 4px;
      color: white;
    }
    #particleModal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(10, 15, 30, 0.95);
      border: 2px solid #4f46e5;
      border-radius: 15px;
      padding: 25px;
      display: none;
      z-index: 20;
      color: white;
      width: 90%;
      max-width: 500px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
      max-height: 80vh;
      overflow-y: auto;
    }
    #particleModal.show {
      display: block;
      animation: fadeIn 0.3s ease;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translate(-50%, -45%); }
      to { opacity: 1; transform: translate(-50%, -50%); }
    }
    .grid-label {
      font-family: Arial, sans-serif;
      margin: 15px 0 10px;
      color: #93c5fd;
      font-weight: bold;
      text-transform: uppercase;
      font-size: 14px;
    }
    .particle-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin: 15px 0;
    }
    .particle-button {
      padding: 12px;
      text-align: center;
      border: 1px solid #4f46e5;
      border-radius: 8px;
      cursor: pointer;
      background: rgba(30, 30, 50, 0.8);
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    .particle-button:hover {
      background: rgba(79, 70, 229, 0.3);
      transform: translateY(-2px);
    }
    .particle-color {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: inline-block;
    }
    .particle-name {
      font-size: 14px;
      font-weight: 500;
    }
    .beam-line {
      position: absolute;
      height: 2px;
      background: rgba(100, 200, 255, 0.2);
      z-index: 1;
    }
    #topBeam {
      top: 25%;
      left: 0;
      width: 100%;
    }
    #bottomBeam {
      top: 75%;
      left: 0;
      width: 100%;
    }
    .instructions-btn {
      position: absolute;
      top: 20px;
      right: 165px;
      z-index: 10;
      background: rgba(20, 20, 30, 0.85);
      border: 1px solid rgba(100, 150, 255, 0.2);
      border-radius: 8px;
      padding: 10px 15px;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
      /*
        BUG FIX: Removed 'pointer-events: none;' and 'opacity: 0;'
        These properties made the button invisible and unclickable.
      */
    }
    .instructions-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(10, 15, 30, 0.95);
      border: 2px solid #4f46e5;
      border-radius: 15px;
      padding: 25px;
      display: none;
      z-index: 20;
      color: white;
      width: 90%;
      max-width: 500px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
    }
    .instructions-modal.show {
      display: block;
      animation: fadeIn 0.3s ease;
    }
    .instructions-modal h2 {
      margin-top: 0;
      color: #93c5fd;
    }
    .instructions-modal ul {
      padding-left: 20px;
    }
    .instructions-modal li {
      margin-bottom: 10px;
      line-height: 1.5;
    }
    .close-instructions {
      position: absolute;
      top: 15px;
      right: 15px;
      background: none;
      border: none;
      color: #ff6b6b;
      font-size: 24px;
      cursor: pointer;
    }
    #leftParticleBtn, #rightParticleBtn {
      position: absolute;
      bottom: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 15px;
      z-index: 10;
      background: rgba(20, 20, 30, 0.85);
      border: 1px solid rgba(100, 150, 255, 0.2);
      border-radius: 12px;
      min-width: 160px;
    }
    #leftParticleBtn {
      left: 20px;
    }
    #rightParticleBtn {
      right: 20px;
    }
    .particle-preview {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background-color: #f44336;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
      cursor: pointer;
    }
    .particle-info {
      text-align: center;
      font-size: 12px;
      color: #a0aec0;
    }
    .particle-info div {
      margin: 2px 0;
    }
    #statsToggle {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 10;
      background: rgba(20, 20, 30, 0.85);
      border: 1px solid rgba(100, 150, 255, 0.2);
      border-radius: 8px;
      padding: 10px 15px;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
      color: white;
    }
    #statsDisplay {
      position: absolute;
      top: 70px;
      right: 20px;
      z-index: 10;
      background: rgba(20, 20, 30, 0.85);
      border: 1px solid rgba(100, 150, 255, 0.2);
      border-radius: 8px;
      padding: 15px;
      font-size: 14px;
      color: #e2e8f0;
      display: none;
      min-width: 300px;
      max-height: 80vh;
      overflow-y: auto;
    }
    #statsDisplay.show {
      display: block;
    }
    .stat-section {
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(100, 150, 255, 0.2);
    }
    .stat-section:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }
    .stat-section-title {
      font-weight: bold;
      color: #64b5f6;
      margin-bottom: 8px;
      font-size: 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .stat-section-title::after {
      content: "▼";
      transition: transform 0.3s ease;
    }
    .stat-section-title.collapsed::after {
      transform: rotate(-90deg);
    }
    .stat-content {
      max-height: 1000px;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    .stat-content.collapsed {
      max-height: 0;
    }
    .stat-item {
      margin: 5px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .stat-value {
      font-weight: bold;
      color: #a78bfa;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 10px 0;
      font-size: 12px;
    }
    th, td {
      padding: 6px 8px;
      text-align: left;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    th {
      background: rgba(100, 150, 255, 0.2);
      font-weight: bold;
    }
    .chart-container {
      height: 100px;
      margin: 10px 0;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 5px;
      position: relative;
      overflow: hidden;
    }
    #momentumToggle {
      margin-left: 15px;
      display: inline-flex;
      align-items: center;
      gap: 5px;
    }
    #momentumToggle input {
      margin: 0;
    }
    .view-toggle {
      display: flex;
      gap: 5px;
      margin-left: 10px;
    }
    .view-toggle button {
      padding: 3px 8px;
      font-size: 12px;
      background: rgba(79, 70, 229, 0.3);
      border: none;
      border-radius: 4px;
      color: white;
      cursor: pointer;
    }
    .view-toggle button.active {
      background: #4f46e5;
    }
    .table-view {
      display: none;
      margin-top: 10px;
    }
    .table-view.show {
      display: block;
    }
    .table-view table {
      width: 100%;
      border-collapse: collapse;
      margin: 0;
    }
    .table-view th, .table-view td {
      padding: 4px 6px;
      text-align: left;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    .table-view th {
      background: rgba(100, 150, 255, 0.2);
      position: sticky;
      top: 0;
    }
    /* BUG FIX: Added a .hidden class to support view toggling logic. */
    .hidden {
        display: none !important;
    }

    /* --- Additions/Modifications for Floating Graph Window --- */
    #floatingGraphWindow {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000; /* High z-index to be on top */
      background: rgba(20, 20, 30, 0.95);
      border: 2px solid rgba(100, 150, 255, 0.5);
      border-radius: 12px;
      padding: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
      display: none; /* Hidden by default */
      min-width: 400px;
      max-width: 90vw; /* Responsive width */
      cursor: move; /* Indicate it's draggable */
      user-select: none; /* Prevent text selection while dragging */
    }
    #floatingGraphWindow.show {
      display: block;
    }
    #floatingGraphHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      color: #64b5f6;
      font-weight: bold;
      cursor: move; /* Indicate header is draggable */
    }
    #closeFloatingGraph {
      background: none;
      border: none;
      color: #ff6b6b;
      font-size: 20px;
      cursor: pointer;
      padding: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #floatingGraphTitle {
      margin: 0;
      font-size: 16px;
      cursor: move; /* Indicate title is draggable */
    }
    #floatingGraphCanvasContainer {
      height: 200px; /* Fixed height for the chart */
      width: 100%;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      overflow: hidden;
    }
    #floatingGraphCanvasContainer canvas {
       width: 100%;
       height: 100%;
       display: block;
    }
    /* -------------------------- */
  </style>
</head>
<body>
  <div class="beam-line" id="topBeam"></div>
  <div class="beam-line" id="bottomBeam"></div>
  <div id="controls">
    <button id="playPauseBtn">▶️</button>
    <button id="resetBtn">Reset</button>
    <button id="oneParticleBtn">1 Particle</button>
    <div class="slider-container">
      <span class="slider-label">Time Scale:</span>
      <input id="timeScaleInput" type="range" min="0.1" max="5" step="0.1" value="1" />
      <span id="timeScaleValue">1.0</span>
    </div>
    <label for="particleCountInput">
      Particle Count:
      <input id="particleCountInput" type="number" min="1" max="10" value="4" />
    </label>
    <label id="momentumToggle">
      <input type="checkbox" id="momentumCheckbox">
      <span>Show Momentum</span>
    </label>
  </div>
  <button id="statsToggle">
    <input type="checkbox" id="statsCheckbox">
    <label for="statsCheckbox">Statistics</label>
  </button>
  <div id="statsDisplay">
    <!-- Particle Overview -->
    <div class="stat-section">
      <div class="stat-section-title">📦 Particle Overview</div>
      <div class="stat-content">
        <div class="stat-item">
          <span>Total Particles: <span id="totalParticles" class="stat-value">0</span></span>
          <div class="view-toggle">
            <button class="graph-btn" data-metric="totalParticles">Graph</button>
            <button class="table-btn" data-metric="totalParticles">Table</button>
          </div>
        </div>
        <div class="chart-container" id="totalParticlesChart"></div>
        <div class="table-view" id="totalParticlesTable">
          <table>
            <thead>
              <tr>
                <th>Time (s)</th>
                <th>Value</th>
              </tr>
            </thead>
            <tbody id="totalParticlesTableBody"></tbody>
          </table>
        </div>
        
        <div class="stat-item">
          <span>Active / Decayed: <span id="activeDecayed" class="stat-value">0 / 0</span></span>
          <div class="view-toggle">
            <button class="graph-btn" data-metric="activeDecayed">Graph</button>
            <button class="table-btn" data-metric="activeDecayed">Table</button>
          </div>
        </div>
        <div class="chart-container" id="activeDecayedChart"></div>
        <div class="table-view" id="activeDecayedTable">
          <table>
            <thead>
              <tr>
                <th>Time (s)</th>
                <th>Active</th>
                <th>Decayed</th>
              </tr>
            </thead>
            <tbody id="activeDecayedTableBody"></tbody>
          </table>
        </div>
        
        <div class="stat-item">
          <span>From Beams: <span id="beamParticles" class="stat-value">0</span></span>
          <div class="view-toggle">
            <button class="graph-btn" data-metric="beamParticles">Graph</button>
            <button class="table-btn" data-metric="beamParticles">Table</button>
          </div>
        </div>
        <div class="chart-container" id="beamParticlesChart"></div>
        <div class="table-view" id="beamParticlesTable">
          <table>
            <thead>
              <tr>
                <th>Time (s)</th>
                <th>Value</th>
              </tr>
            </thead>
            <tbody id="beamParticlesTableBody"></tbody>
          </table>
        </div>
        
        <div class="stat-item">
          <span>From Decays: <span id="decayParticles" class="stat-value">0</span></span>
          <div class="view-toggle">
            <button class="graph-btn" data-metric="decayParticles">Graph</button>
            <button class="table-btn" data-metric="decayParticles">Table</button>
          </div>
        </div>
        <div class="chart-container" id="decayParticlesChart"></div>
        <div class="table-view" id="decayParticlesTable">
          <table>
            <thead>
              <tr>
                <th>Time (s)</th>
                <th>Value</th>
              </tr>
            </thead>
            <tbody id="decayParticlesTableBody"></tbody>
          </table>
        </div>
        
        <div class="stat-item">
          <span>Max Decay Chain: <span id="maxDecayChain" class="stat-value">0</span></span>
          <div class="view-toggle">
            <button class="graph-btn" data-metric="maxDecayChain">Graph</button>
            <button class="table-btn" data-metric="maxDecayChain">Table</button>
          </div>
        </div>
        <div class="chart-container" id="maxDecayChainChart"></div>
        <div class="table-view" id="maxDecayChainTable">
          <table>
            <thead>
              <tr>
                <th>Time (s)</th>
                <th>Value</th>
              </tr>
            </thead>
            <tbody id="maxDecayChainTableBody"></tbody>
          </table>
        </div>
      </div>
    </div>
    
    <!-- Composition Breakdown -->
    <div class="stat-section">
      <div class="stat-section-title">🧬 Composition Breakdown</div>
      <div class="stat-content">
        <table>
          <thead>
            <tr>
              <th>Type</th>
              <th>Count</th>
              <th>Percentage</th>
            </tr>
          </thead>
          <tbody id="compositionTable">
            <tr>
              <td colspan="3">No data</td>
            </tr>
          </tbody>
        </table>
        <div class="stat-item">
          <span>Composition</span>
          <div class="view-toggle">
            <button class="graph-btn" data-metric="composition">Graph</button>
            <button class="table-btn" data-metric="composition">Table</button>
          </div>
        </div>
        <div class="chart-container" id="compositionChart"></div>
        <div class="table-view" id="compositionTableContainer">
          <table>
            <thead>
              <tr>
                <th>Time (s)</th>
                <th>Type</th>
                <th>Count</th>
              </tr>
            </thead>
            <tbody id="compositionTableBody"></tbody>
          </table>
        </div>
      </div>
    </div>
    
    <!-- Speed & Energy -->
    <div class="stat-section">
      <div class="stat-section-title">📈 Speed & Energy</div>
      <div class="stat-content">
        <table>
          <thead>
            <tr>
              <th>Metric</th>
              <th>Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Avg Speed</td>
              <td><span id="avgSpeed" class="stat-value">0.00</span></td>
            </tr>
            <tr>
              <td>Avg Energy</td>
              <td><span id="avgEnergy" class="stat-value">0.00</span></td>
            </tr>
            <tr>
              <td>Max Energy</td>
              <td><span id="maxEnergy" class="stat-value">0.00 (None)</span></td>
            </tr>
            <tr>
              <td>Min Energy</td>
              <td><span id="minEnergy" class="stat-value">0.00 (None)</span></td>
            </tr>
          </tbody>
        </table>
        <div class="stat-item">
          <span>Avg Speed</span>
          <div class="view-toggle">
            <button class="graph-btn" data-metric="avgSpeed">Graph</button>
            <button class="table-btn" data-metric="avgSpeed">Table</button>
          </div>
        </div>
        <div class="chart-container" id="avgSpeedChart"></div>
        <div class="table-view" id="avgSpeedTable">
          <table>
            <thead>
              <tr>
                <th>Time (s)</th>
                <th>Value</th>
              </tr>
            </thead>
            <tbody id="avgSpeedTableBody"></tbody>
          </table>
        </div>
        
        <div class="stat-item">
          <span>Avg Energy</span>
          <div class="view-toggle">
            <button class="graph-btn" data-metric="avgEnergy">Graph</button>
            <button class="table-btn" data-metric="avgEnergy">Table</button>
          </div>
        </div>
        <div class="chart-container" id="avgEnergyChart"></div>
        <div class="table-view" id="avgEnergyTable">
          <table>
            <thead>
              <tr>
                <th>Time (s)</th>
                <th>Value</th>
              </tr>
            </thead>
            <tbody id="avgEnergyTableBody"></tbody>
          </table>
        </div>
        
        <div class="stat-item">
          <span>Max Energy</span>
          <div class="view-toggle">
            <button class="graph-btn" data-metric="maxEnergy">Graph</button>
            <button class="table-btn" data-metric="maxEnergy">Table</button>
          </div>
        </div>
        <div class="chart-container" id="maxEnergyChart"></div>
        <div class="table-view" id="maxEnergyTable">
          <table>
            <thead>
              <tr>
                <th>Time (s)</th>
                <th>Value</th>
                <th>Particle</th>
              </tr>
            </thead>
            <tbody id="maxEnergyTableBody"></tbody>
          </table>
        </div>
        
        <div class="stat-item">
          <span>Min Energy</span>
          <div class="view-toggle">
            <button class="graph-btn" data-metric="minEnergy">Graph</button>
            <button class="table-btn" data-metric="minEnergy">Table</button>
          </div>
        </div>
        <div class="chart-container" id="minEnergyChart"></div>
        <div class="table-view" id="minEnergyTable">
          <table>
            <thead>
              <tr>
                <th>Time (s)</th>
                <th>Value</th>
                <th>Particle</th>
              </tr>
            </thead>
            <tbody id="minEnergyTableBody"></tbody>
          </table>
        </div>
      </div>
    </div>
    
    <!-- Distance & Lifetime -->
    <div class="stat-section">
      <div class="stat-section-title">🌀 Distance & Lifetime</div>
      <div class="stat-content">
        <table>
          <thead>
            <tr>
              <th>Metric</th>
              <th>Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Total Distance</td>
              <td><span id="totalDistance" class="stat-value">0.00</span></td>
            </tr>
            <tr>
              <td>Avg Distance</td>
              <td><span id="avgDistance" class="stat-value">0.00</span></td>
            </tr>
            <tr>
              <td>Avg Lifetime</td>
              <td><span id="avgLifetime" class="stat-value">0.00</span></td>
            </tr>
          </tbody>
        </table>
        <div class="stat-item">
          <span>Total Distance</span>
          <div class="view-toggle">
            <button class="graph-btn" data-metric="totalDistance">Graph</button>
            <button class="table-btn" data-metric="totalDistance">Table</button>
          </div>
        </div>
        <div class="chart-container" id="totalDistanceChart"></div>
        <div class="table-view" id="totalDistanceTable">
          <table>
            <thead>
              <tr>
                <th>Time (s)</th>
                <th>Value</th>
              </tr>
            </thead>
            <tbody id="totalDistanceTableBody"></tbody>
          </table>
        </div>
        
        <div class="stat-item">
          <span>Avg Distance</span>
          <div class="view-toggle">
            <button class="graph-btn" data-metric="avgDistance">Graph</button>
            <button class="table-btn" data-metric="avgDistance">Table</button>
          </div>
        </div>
        <div class="chart-container" id="avgDistanceChart"></div>
        <div class="table-view" id="avgDistanceTable">
          <table>
            <thead>
              <tr>
                <th>Time (s)</th>
                <th>Value</th>
              </tr>
            </thead>
            <tbody id="avgDistanceTableBody"></tbody>
          </table>
        </div>
        
        <div class="stat-item">
          <span>Avg Lifetime</span>
          <div class="view-toggle">
            <button class="graph-btn" data-metric="avgLifetime">Graph</button>
            <button class="table-btn" data-metric="avgLifetime">Table</button>
          </div>
        </div>
        <div class="chart-container" id="avgLifetimeChart"></div>
        <div class="table-view" id="avgLifetimeTable">
          <table>
            <thead>
              <tr>
                <th>Time (s)</th>
                <th>Value</th>
              </tr>
            </thead>
            <tbody id="avgLifetimeTableBody"></tbody>
          </table>
        </div>
      </div>
    </div>
    
    <!-- Events -->
    <div class="stat-section">
      <div class="stat-section-title">💥 Events (Collisions & Decays)</div>
      <div class="stat-content">
        <table>
          <thead>
            <tr>
              <th>Event</th>
              <th>Count</th>
              <th>Rate</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Collisions</td>
              <td><span id="collisionCount" class="stat-value">0</span></td>
              <td><span id="collisionRate" class="stat-value">0.0/s</span></td>
            </tr>
            <tr>
              <td>Decays</td>
              <td><span id="decayCount" class="stat-value">0</span></td>
              <td><span id="decayRate" class="stat-value">0.0/s</span></td>
            </tr>
          </tbody>
        </table>
        <div class="stat-item">
          <span>Collisions</span>
          <div class="view-toggle">
            <button class="graph-btn" data-metric="collisions">Graph</button>
            <button class="table-btn" data-metric="collisions">Table</button>
          </div>
        </div>
        <div class="chart-container" id="collisionsChart"></div>
        <div class="table-view" id="collisionsTable">
          <table>
            <thead>
              <tr>
                <th>Time (s)</th>
                <th>Count</th>
                <th>Rate</th>
              </tr>
            </thead>
            <tbody id="collisionsTableBody"></tbody>
          </table>
        </div>
        
        <div class="stat-item">
          <span>Decays</span>
          <div class="view-toggle">
            <button class="graph-btn" data-metric="decays">Graph</button>
            <button class="table-btn" data-metric="decays">Table</button>
          </div>
        </div>
        <div class="chart-container" id="decaysChart"></div>
        <div class="table-view" id="decaysTable">
          <table>
            <thead>
              <tr>
                <th>Time (s)</th>
                <th>Count</th>
                <th>Rate</th>
              </tr>
            </thead>
            <tbody id="decaysTableBody"></tbody>
          </table>
        </div>
        
        <div class="stat-item">
          <span>Top Decay: <span id="topDecays" class="stat-value">None</span></span>
          <div class="view-toggle">
            <button class="graph-btn" data-metric="topDecays">Graph</button>
            <button class="table-btn" data-metric="topDecays">Table</button>
          </div>
        </div>
        <div class="chart-container" id="topDecaysChart"></div>
        <div class="table-view" id="topDecaysTable">
          <table>
            <thead>
              <tr>
                <th>Time (s)</th>
                <th>Decay</th>
                <th>Count</th>
              </tr>
            </thead>
            <tbody id="topDecaysTableBody"></tbody>
          </table>
        </div>
      </div>
    </div>
    
    <!-- Beam vs Decay Energy -->
    <div class="stat-section">
      <div class="stat-section-title">⚡ Beam vs Decay Energy</div>
      <div class="stat-content">
        <div class="stat-item">
          <span>Beam Energy: <span id="beamEnergy" class="stat-value">0.00</span></span>
          <div class="view-toggle">
            <button class="graph-btn" data-metric="beamEnergy">Graph</button>
            <button class="table-btn" data-metric="beamEnergy">Table</button>
          </div>
        </div>
        <div class="chart-container" id="beamEnergyChart"></div>
        <div class="table-view" id="beamEnergyTable">
          <table>
            <thead>
              <tr>
                <th>Time (s)</th>
                <th>Value</th>
              </tr>
            </thead>
            <tbody id="beamEnergyTableBody"></tbody>
          </table>
        </div>
        
        <div class="stat-item">
          <span>Decay Energy: <span id="decayEnergy" class="stat-value">0.00</span></span>
          <div class="view-toggle">
            <button class="graph-btn" data-metric="decayEnergy">Graph</button>
            <button class="table-btn" data-metric="decayEnergy">Table</button>
          </div>
        </div>
        <div class="chart-container" id="decayEnergyChart"></div>
        <div class="table-view" id="decayEnergyTable">
          <table>
            <thead>
              <tr>
                <th>Time (s)</th>
                <th>Value</th>
              </tr>
            </thead>
            <tbody id="decayEnergyTableBody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
  <button class="instructions-btn" id="instructionsBtn">
    <span>?</span> How to Use
  </button>
  <div class="instructions-modal" id="instructionsModal">
    <button class="close-instructions" id="closeInstructions">&times;</button>
    <h2>How to Use</h2>
    <ul>
      <li>Select particle types for each beam</li>
      <li>Click ▶️ to start particle generation</li>
      <li>Click ⏸️ to pause all particles</li>
      <li>Use "1 Particle" for single collision</li>
      <li>Adjust time scale and particle count</li>
    </ul>
  </div>
  <button id="leftParticleBtn">
    <div class="particle-preview" id="leftParticlePreview"></div>
    <div class="particle-info">
      <div id="leftParticleName">Proton</div>
      <div id="leftParticleMass">Mass: 938.3 MeV</div>
      <div id="leftParticleCharge">Charge: +1</div>
      <div id="leftParticleLifetime">Lifetime: Stable</div>
    </div>
  </button>
  <button id="rightParticleBtn">
    <div class="particle-preview" id="rightParticlePreview"></div>
    <div class="particle-info">
      <div id="rightParticleName">Anti-Proton</div>
      <div id="rightParticleMass">Mass: 938.3 MeV</div>
      <div id="rightParticleCharge">Charge: -1</div>
      <div id="rightParticleLifetime">Lifetime: Stable</div>
    </div>
  </button>
  <div id="particleModal">
    <div id="particleModalContent">
      <h2>Select Particle Type</h2>
      <p>Choose a particle for the <span id="beamSideLabel">left</span> beam:</p>
      <div class="grid-label">Standard Model</div>
      <div class="particle-grid" id="normalParticles"></div>
      <div class="grid-label">Antimatter Counterparts</div>
      <div class="particle-grid" id="antiParticles"></div>
      <button id="closeParticleModal" style="width: 100%; margin-top: 15px;">Close</button>
    </div>
  </div>

  <!-- Add the Floating Graph Window HTML -->
  <div id="floatingGraphWindow">
    <div id="floatingGraphHeader">
      <h3 id="floatingGraphTitle">Metric Graph</h3>
      <button id="closeFloatingGraph">&times;</button>
    </div>
    <div id="floatingGraphCanvasContainer"></div>
  </div>

  <canvas id="sim"></canvas>
  <script>
  window.addEventListener("DOMContentLoaded", () => {
    const canvas = document.getElementById("sim");
    const ctx = canvas.getContext("2d");
    const playPauseBtn = document.getElementById("playPauseBtn");
    const resetBtn = document.getElementById("resetBtn");
    const oneParticleBtn = document.getElementById("oneParticleBtn");
    const timeScaleInput = document.getElementById("timeScaleInput");
    const timeScaleValue = document.getElementById("timeScaleValue");
    const particleCountInput = document.getElementById("particleCountInput");
    const instructionsBtn = document.getElementById("instructionsBtn");
    const instructionsModal = document.getElementById("instructionsModal");
    const closeInstructions = document.getElementById("closeInstructions");
    const leftParticlePreview = document.getElementById("leftParticlePreview");
    const rightParticlePreview = document.getElementById("rightParticlePreview");
    const leftParticleName = document.getElementById("leftParticleName");
    const rightParticleName = document.getElementById("rightParticleName");
    const leftParticleMass = document.getElementById("leftParticleMass");
    const rightParticleMass = document.getElementById("rightParticleMass");
    const leftParticleCharge = document.getElementById("leftParticleCharge");
    const rightParticleCharge = document.getElementById("rightParticleCharge");
    const leftParticleLifetime = document.getElementById("leftParticleLifetime");
    const rightParticleLifetime = document.getElementById("rightParticleLifetime");
    const statsToggle = document.getElementById("statsToggle");
    const statsCheckbox = document.getElementById("statsCheckbox");
    const statsDisplay = document.getElementById("statsDisplay");
    const momentumCheckbox = document.getElementById("momentumCheckbox");
    // Stats elements
    const totalParticles = document.getElementById("totalParticles");
    const activeDecayed = document.getElementById("activeDecayed");
    const beamParticles = document.getElementById("beamParticles");
    const decayParticles = document.getElementById("decayParticles");
    const maxDecayChain = document.getElementById("maxDecayChain");
    const compositionTable = document.getElementById("compositionTable");
    const avgSpeed = document.getElementById("avgSpeed");
    const avgEnergy = document.getElementById("avgEnergy");
    const maxEnergy = document.getElementById("maxEnergy");
    const minEnergy = document.getElementById("minEnergy");
    const totalDistance = document.getElementById("totalDistance");
    const avgDistance = document.getElementById("avgDistance");
    const avgLifetime = document.getElementById("avgLifetime");
    const collisionCount = document.getElementById("collisionCount");
    const collisionRate = document.getElementById("collisionRate");
    const decayCount = document.getElementById("decayCount");
    const decayRate = document.getElementById("decayRate");
    const topDecays = document.getElementById("topDecays");
    const beamEnergy = document.getElementById("beamEnergy");
    const decayEnergy = document.getElementById("decayEnergy");
    let timeScale = 1;
    let particleCount = 4;
    let spawnInterval = null;
    let spawnIntervalId = null;
    let collisionCounter = 0;
    let decayCounter = 0;
    let decayLog = [];
    let collisionTimes = [];
    let lastStatsUpdate = Date.now();
    let particleLifetimes = []; // For tracking decay lifetimes
    let energyLostToDecay = 0; // Total energy lost to decay
    let recentDecayChain = "None"; // Most recent decay chain
    let totalSimulationTime = 0; // Total simulation time in seconds
    let lastFrameTime = Date.now(); // For calculating deltaTime
    let simulationStartTime = Date.now(); // For tracking simulation time
    // Data storage for charts and tables
    let statsData = {
      totalParticles: [],
      activeDecayed: [],
      beamParticles: [],
      decayParticles: [],
      maxDecayChain: [],
      avgSpeed: [],
      avgEnergy: [],
      maxEnergy: [],
      minEnergy: [],
      totalDistance: [],
      avgDistance: [],
      avgLifetime: [],
      collisions: [],
      decays: [],
      beamEnergy: [],
      decayEnergy: [],
      composition: [],
      topDecays: []
    };
    // Update slider background
    function updateSliderBackground() {
      const value = (timeScaleInput.value - timeScaleInput.min) / (timeScaleInput.max - timeScaleInput.min) * 100;
      timeScaleInput.style.setProperty('--value', value + '%');
    }
    timeScaleInput.addEventListener("input", () => {
      timeScale = parseFloat(timeScaleInput.value) || 1;
      timeScaleValue.textContent = timeScale.toFixed(1);
      updateSliderBackground();
      // Adjust spawn interval based on time scale
      if (spawnIntervalId) {
        clearInterval(spawnIntervalId);
        spawnIntervalId = setInterval(createParticles, spawnInterval / timeScale);
      }
    });
    updateSliderBackground();
    particleCountInput.addEventListener("change", () => {
      particleCount = parseInt(particleCountInput.value) || 4;
      if (particleCount < 1) particleCount = 1;
      if (particleCount > 10) particleCount = 10;
      particleCountInput.value = particleCount;
    });
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);
    window.particles = [];
    const particles = window.particles;
    window.collisions = [];
    let collisions = window.collisions;
    let animationId = null;
    let running = false;
    const bandTop = () => canvas.height * 0.25;
    const bandBottom = () => canvas.height * 0.75;
    const baseSpawnInterval = 750; // 750ms at timeScale = 1
    spawnInterval = baseSpawnInterval;
    // Particle creation - batch particles
    function createParticles() {
      const baseRadius = 6;
      const scaledRadius = baseRadius * (10 / particleCount);
      for (let i = 0; i < particleCount; i++) {
        // LEFT beam particles
        particles.push({
          x: scaledRadius + Math.random() * 30,
          y: bandTop() + Math.random() * (bandBottom() - bandTop()),
          r: scaledRadius,
          vx: 8 + Math.random() * 4, // Increased base speed
          vy: (Math.random() - 0.5) * 2, // Increased vertical variation
          beam: "left",
          color: selectedParticles.left.color,
          name: selectedParticles.left.name || "Proton",
          lifetime: 1000,
          decayed: false,
          decayProducts: [],
          spawnTime: Date.now(),
          origin: "left",
          decayChainLength: 0,
          distanceTraveled: 0 // Track distance traveled
        });
        // RIGHT beam particles
        particles.push({
          x: canvas.width - scaledRadius - Math.random() * 30,
          y: bandTop() + Math.random() * (bandBottom() - bandTop()),
          r: scaledRadius,
          vx: -8 - Math.random() * 4, // Increased base speed
          vy: (Math.random() - 0.5) * 2, // Increased vertical variation
          beam: "right",
          color: selectedParticles.right.color,
          name: selectedParticles.right.name || "Proton",
          lifetime: 1000,
          decayed: false,
          decayProducts: [],
          spawnTime: Date.now(),
          origin: "right",
          decayChainLength: 0,
          distanceTraveled: 0 // Track distance traveled
        });
      }
    }
    // Create single particle pair
    function createSingleParticlePair() {
      const radius = 8;
      // LEFT beam particle
      particles.push({
        x: radius,
        y: (bandTop() + bandBottom()) / 2,
        r: radius,
        vx: 10, // Higher speed
        vy: 0,
        beam: "left",
        color: selectedParticles.left.color,
        name: selectedParticles.left.name || "Proton",
        lifetime: 1000,
        decayed: false,
        decayProducts: [],
        spawnTime: Date.now(),
        origin: "left",
        decayChainLength: 0,
        distanceTraveled: 0 // Track distance traveled
      });
      // RIGHT beam particle
      particles.push({
        x: canvas.width - radius,
        y: (bandTop() + bandBottom()) / 2,
        r: radius,
        vx: -10, // Higher speed
        vy: 0,
        beam: "right",
        color: selectedParticles.right.color,
        name: selectedParticles.right.name || "Proton",
        lifetime: 1000,
        decayed: false,
        decayProducts: [],
        spawnTime: Date.now(),
        origin: "right",
        decayChainLength: 0,
        distanceTraveled: 0 // Track distance traveled
      });
      // Ensure animation is running to show the particles
      if (!running) {
        if (!animationId) {
          animationId = requestAnimationFrame(loop);
        }
      }
    }
    // Draw momentum arrow for a particle
    function drawMomentumArrow(p) {
      const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
      // Only draw arrow if speed is above threshold
      if (speed > 0.5) {
        const scale = 5; // Scale factor for arrow length
        const arrowLength = Math.min(speed * scale, 30); // Cap arrow length
        const angle = Math.atan2(p.vy, p.vx);
        // Arrow color based on particle type (matter vs antimatter)
        const isAntimatter = p.name.includes("Anti") || p.name.includes("anti");
        const color = isAntimatter ? 'purple' : 'hotpink';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(
          p.x + Math.cos(angle) * arrowLength,
          p.y + Math.sin(angle) * arrowLength
        );
        ctx.stroke();
        // Draw arrowhead
        const headLength = 10;
        ctx.beginPath();
        ctx.moveTo(
          p.x + Math.cos(angle) * arrowLength,
          p.y + Math.sin(angle) * arrowLength
        );
        ctx.lineTo(
          p.x + Math.cos(angle - Math.PI/6) * (arrowLength - headLength),
          p.y + Math.sin(angle - Math.PI/6) * (arrowLength - headLength)
        );
        ctx.lineTo(
          p.x + Math.cos(angle + Math.PI/6) * (arrowLength - headLength),
          p.y + Math.sin(angle + Math.PI/6) * (arrowLength - headLength)
        );
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
      }
    }
    function drawParticles() {
      // Draw beam regions
      ctx.fillStyle = "rgba(50, 50, 100, 0.1)";
      ctx.fillRect(0, bandTop(), canvas.width, bandBottom() - bandTop());
      // Draw primary particles
      for (let p of particles) {
        if (!p.decayed) {
          // Clamp minimum speed to prevent particles from moving too slowly
          if (Math.abs(p.vx) < 0.5) p.vx = 0.5 * Math.sign(p.vx || 1);
          if (Math.abs(p.vy) < 0.5) p.vy = 0.5 * Math.sign(p.vy || 1);
          // Draw particle glow
          ctx.shadowColor = p.color;
          ctx.shadowBlur = 15;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
          // Draw particle core
          ctx.fillStyle = "#ffffff";
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r * 0.4, 0, Math.PI * 2);
          ctx.fill();
          // Draw momentum arrows if enabled
          if (momentumCheckbox.checked) {
            drawMomentumArrow(p);
          }
        }
      }
      // Draw decay products with improved visuals
      for (let p of particles) {
        if (p.decayProducts && p.decayProducts.length > 0) {
          for (let dp of p.decayProducts) {
            if (dp.lifetime > 0) {
              // Clamp minimum speed
              if (Math.abs(dp.vx) < 0.5) dp.vx = 0.5 * Math.sign(dp.vx || 1);
              if (Math.abs(dp.vy) < 0.5) dp.vy = 0.5 * Math.sign(dp.vy || 1);
              // Draw decay particle with trail effect
              if (dp.trail) {
                for (let i = 0; i < dp.trail.length; i++) {
                  const point = dp.trail[i];
                  const alpha = i / dp.trail.length;
                  ctx.fillStyle = `rgba(${parseInt(dp.color.substr(1, 2), 16)}, ${parseInt(dp.color.substr(3, 2), 16)}, ${parseInt(dp.color.substr(5, 2), 16)}, ${alpha * 0.5})`;
                  ctx.beginPath();
                  ctx.arc(point.x, point.y, dp.r * alpha, 0, Math.PI * 2);
                  ctx.fill();
                }
              }
              // Draw particle glow
              ctx.shadowColor = dp.color;
              ctx.shadowBlur = 10;
              ctx.fillStyle = dp.color;
              ctx.beginPath();
              ctx.arc(dp.x, dp.y, dp.r, 0, Math.PI * 2);
              ctx.fill();
              ctx.shadowBlur = 0;
              // Draw particle core
              ctx.fillStyle = "#ffffff";
              ctx.beginPath();
              ctx.arc(dp.x, p.y, dp.r * 0.3, 0, Math.PI * 2);
              ctx.fill();
              // Draw momentum arrows if enabled
              if (momentumCheckbox.checked) {
                drawMomentumArrow(dp);
              }
            }
          }
        }
      }
      // Draw collision flashes
      const now = Date.now();
      for (let i = collisions.length - 1; i >= 0; i--) {
        const c = collisions[i];
        const elapsed = now - c.time;
        const duration = 400 / timeScale;
        if (elapsed > duration) {
          collisions.splice(i, 1);
          continue;
        }
        const alpha = 1 - elapsed / duration;
        // Create radial gradient for flash
        const gradient = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, c.r * 3);
        gradient.addColorStop(0, `rgba(${c.color.r}, ${c.color.g}, ${c.color.b}, ${alpha})`);
        gradient.addColorStop(1, `rgba(${c.color.r}, ${c.color.g}, ${c.color.b}, 0)`);
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.r * 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    function updateParticles() {
      // Move primary particles and track distance
      for (let p of particles) {
        if (!p.decayed) {
          // Clamp minimum speed
          if (Math.abs(p.vx) < 0.5) p.vx = 0.5 * Math.sign(p.vx || 1);
          if (Math.abs(p.vy) < 0.5) p.vy = 0.5 * Math.sign(p.vy || 1);
          // Calculate distance traveled in this frame
          const dx = p.vx * timeScale;
          const dy = p.vy * timeScale;
          const distance = Math.sqrt(dx * dx + dy * dy);
          p.distanceTraveled += distance;
          p.x += dx;
          p.y += dy;
          // Bounce vertically inside the band limits
          if (p.y < bandTop() + p.r || p.y > bandBottom() - p.r) {
            p.vy *= -1;
          }
          // Reduce lifetime
          if (p.lifetime !== undefined && p.lifetime > 0) {
            p.lifetime -= timeScale;
            if (p.lifetime < 0) p.lifetime = 0;
          }
        }
      }
      // Update decay products
      for (let p of particles) {
        if (p.decayProducts && p.decayProducts.length > 0) {
          for (let dp of p.decayProducts) {
            if (dp.lifetime > 0) {
              // Clamp minimum speed
              if (Math.abs(dp.vx) < 0.5) dp.vx = 0.5 * Math.sign(dp.vx || 1);
              if (Math.abs(dp.vy) < 0.5) dp.vy = 0.5 * Math.sign(dp.vy || 1);
              // Calculate distance traveled in this frame
              const dx = dp.vx * timeScale;
              const dy = dp.vy * timeScale;
              const distance = Math.sqrt(dx * dx + dy * dy);
              dp.distanceTraveled = (dp.distanceTraveled || 0) + distance;
              // Update position
              dp.x += dx;
              dp.y += dy;
              // Add to trail if needed
              if (dp.trail) {
                dp.trail.push({x: dp.x, y: dp.y});
                if (dp.trail.length > 10) {
                  dp.trail.shift();
                }
              }
              // Reduce lifetime
              dp.lifetime -= timeScale;
              // Add some gravity effect to decay products
              dp.vy += 0.05 * timeScale;
            }
          }
        }
      }
      detectCollisions();
    }
    // Helper: map particle names to colors
    function getColorForParticle(name) {
      const colorMap = {
        // Quarks
        'Up Quark': '#ff6666',
        'Anti-Up Quark': '#ffcccc',
        'Down Quark': '#ff9966',
        'Anti-Down Quark': '#ffcc99',
        'Strange Quark': '#ccff66',
        'Anti-Strange Quark': '#e6ffcc',
        'Charm Quark': '#66ff66',
        'Anti-Charm Quark': '#ccffcc',
        'Bottom Quark': '#6666ff',
        'Anti-Bottom Quark': '#ccccff',
        'Top Quark': '#cc66ff',
        'Anti-Top Quark': '#e6ccff',
        // Leptons
        'Electron': '#4dabf7',
        'Positron': '#ff9e58',
        'Muon': '#51cf66',
        'Anti-Muon': '#90e051',
        'Tau': '#cc5de8',
        'Anti-Tau': '#d0b0ff',
        'Electron Neutrino': '#a0d2ff',
        'Anti-Electron Neutrino': '#d0e0ff',
        'Muon Neutrino': '#80b0d0',
        'Anti-Muon Neutrino': '#b0c8e0',
        'Tau Neutrino': '#404040',
        'Anti-Tau Neutrino': '#606060',
        // Bosons
        'Photon': '#ffffff',
        'W Boson': '#ffff00',
        'Anti-W Boson': '#ffcc00',
        'Z Boson': '#66ff66',
        'Gluon': '#ff6600',
        'Graviton': '#8080ff',
        // Higgs
        'Higgs Boson': '#ffccdd',
        // Composite particles
        'Proton': '#ff6b6b',
        'Anti-Proton': '#b33a3a',
        'Neutron': '#ffff99',
        'Anti-Neutron': '#cccc66',
        'Pion': '#f0c0a0',
        'Charged Pion': '#ff8ad4'
      };
      return colorMap[name] || '#ffffff';
    }
    // Get particle properties
    function getParticleProperties(name) {
      const properties = {
        // Quarks
        'Up Quark': { mass: '~2.2 MeV', charge: '+2/3', lifetime: 'Bound/stable' },
        'Anti-Up Quark': { mass: '~2.2 MeV', charge: '-2/3', lifetime: 'Bound/stable' },
        'Down Quark': { mass: '~4.7 MeV', charge: '-1/3', lifetime: 'Bound/stable' },
        'Anti-Down Quark': { mass: '~4.7 MeV', charge: '+1/3', lifetime: 'Bound/stable' },
        'Strange Quark': { mass: '~96 MeV', charge: '-1/3', lifetime: '~10⁻¹⁰ s' },
        'Anti-Strange Quark': { mass: '~96 MeV', charge: '+1/3', lifetime: '~10⁻¹⁰ s' },
        'Charm Quark': { mass: '~1.27 GeV', charge: '+2/3', lifetime: '~10⁻¹³ s' },
        'Anti-Charm Quark': { mass: '~1.27 GeV', charge: '-2/3', lifetime: '~10⁻¹³ s' },
        'Bottom Quark': { mass: '~4.18 GeV', charge: '-1/3', lifetime: '~1.6×10⁻¹² s' },
        'Anti-Bottom Quark': { mass: '~4.18 GeV', charge: '+1/3', lifetime: '~1.6×10⁻¹² s' },
        'Top Quark': { mass: '~173 GeV', charge: '+2/3', lifetime: '~5×10⁻²⁵ s' },
        'Anti-Top Quark': { mass: '~173 GeV', charge: '-2/3', lifetime: '~5×10⁻²⁵ s' },
        // Leptons
        'Electron': { mass: '0.511 MeV', charge: '-1', lifetime: 'Stable' },
        'Positron': { mass: '0.511 MeV', charge: '+1', lifetime: 'Stable (annihilates)' },
        'Muon': { mass: '105.7 MeV', charge: '-1', lifetime: '2.2×10⁻⁶ s' },
        'Anti-Muon': { mass: '105.7 MeV', charge: '+1', lifetime: '2.2×10⁻⁶ s' },
        'Tau': { mass: '1776.86 MeV', charge: '-1', lifetime: '2.9×10⁻¹³ s' },
        'Anti-Tau': { mass: '1776.86 MeV', charge: '+1', lifetime: '2.9×10⁻¹³ s' },
        'Electron Neutrino': { mass: '< 2.2 eV', charge: '0', lifetime: 'Stable' },
        'Anti-Electron Neutrino': { mass: '< 2.2 eV', charge: '0', lifetime: 'Stable' },
        'Muon Neutrino': { mass: '< 0.17 MeV', charge: '0', lifetime: 'Stable' },
        'Anti-Muon Neutrino': { mass: '< 0.17 MeV', charge: '0', lifetime: 'Stable' },
        'Tau Neutrino': { mass: '< 18.2 MeV', charge: '0', lifetime: 'Stable' },
        'Anti-Tau Neutrino': { mass: '< 18.2 MeV', charge: '0', lifetime: 'Stable' },
        // Bosons
        'Photon': { mass: '0', charge: '0', lifetime: 'Stable' },
        'W Boson': { mass: '~80.4 GeV', charge: '±1', lifetime: '~3×10⁻²⁵ s' },
        'Anti-W Boson': { mass: '~80.4 GeV', charge: '∓1', lifetime: '~3×10⁻²⁵ s' },
        'Z Boson': { mass: '~91.2 GeV', charge: '0', lifetime: '~3×10⁻²⁵ s' },
        'Gluon': { mass: '0', charge: '0', lifetime: 'Stable (confined)' },
        'Graviton': { mass: '0', charge: '0', lifetime: 'Unknown' },
        // Higgs
        'Higgs Boson': { mass: '~125.1 GeV', charge: '0', lifetime: '~1.6×10⁻²² s' },
        // Composite particles
        'Proton': { mass: '938.3 MeV', charge: '+1', lifetime: 'Stable' },
        'Anti-Proton': { mass: '938.3 MeV', charge: '-1', lifetime: 'Stable' },
        'Neutron': { mass: '939.6 MeV', charge: '0', lifetime: '881 s (free)' },
        'Anti-Neutron': { mass: '939.6 MeV', charge: '0', lifetime: '881 s (free)' },
        'Pion': { mass: '139.6 MeV', charge: '0', lifetime: '2.6×10⁻⁸ s' },
        'Charged Pion': { mass: '139.6 MeV', charge: '±1', lifetime: '2.6×10⁻⁸ s' }
      };
      return properties[name] || { mass: 'Unknown', charge: 'Unknown', lifetime: 'Unknown' };
    }
    // Get mass value for calculations
    function getMassValue(name) {
      const masses = {
        'Electron': 0.511,
        'Positron': 0.511,
        'Muon': 105.7,
        'Anti-Muon': 105.7,
        'Tau': 1776.86,
        'Anti-Tau': 1776.86,
        'Photon': 0,
        'Proton': 938.3,
        'Anti-Proton': 938.3,
        'Neutron': 939.6,
        'Anti-Neutron': 939.6,
        'Pion': 139.6,
        'Charged Pion': 139.6,
        'W Boson': 80400,
        'Anti-W Boson': 80400,
        'Z Boson': 91200,
        'Higgs Boson': 125100
      };
      return masses[name] || 100; // Default mass
    }
    // Decay sequence with improved visuals
    function startDecaySequence(particle) {
      if (particle.decayed) return;
      particle.decayed = true;
      decayCounter++;
      // Log decay event
      const decayProducts = generateDecayProducts(particle);
      const decayString = `${particle.name} → ${decayProducts.map(p => p.name).join(" + ")}`;
      decayLog.push({
        parentType: particle.name,
        childrenTypes: decayProducts.map(p => p.name),
        time: Date.now(),
        decayString: decayString
      });
      // Update recent decay chain
      recentDecayChain = decayString;
      particle.decayProducts = [];
      // Record lifetime for average calculation
      const lifetime = (Date.now() - particle.spawnTime) / 1000; // in seconds
      particleLifetimes.push(lifetime);
      // Create spray pattern from collision point
      for (let i = 0; i < decayProducts.length; i++) {
        const decayParticle = decayProducts[i];
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 4; // Increased base speed
        const decayProduct = {
          x: particle.x,
          y: particle.y,
          r: particle.r * 0.6,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          color: getColorForParticle(decayParticle.name) || '#4dabf7',
          name: decayParticle.name,
          lifetime: decayParticle.lifetime || (100 + Math.random() * 200),
          spawnTime: Date.now(),
          origin: "decay",
          decayChainLength: particle.decayChainLength + 1,
          distanceTraveled: 0 // Track distance traveled
        };
        // Add special effects based on particle type
        if (decayParticle.name.includes("Photon")) {
          decayProduct.lifetime = 50;
        } else if (decayParticle.name.includes("Muon") || decayParticle.name.includes("Tau") || 
                   decayParticle.name.includes("W") || decayParticle.name.includes("Z")) {
          decayProduct.trail = [];
        }
        particle.decayProducts.push(decayProduct);
      }
    }
    // Generate decay products based on particle type
    function generateDecayProducts(particle) {
      const name = particle.name;
      // Quarks (stable inside hadrons - simplified decay for simulation)
      if (name === "Strange Quark") {
        return [
          {name: "Up Quark", lifetime: 150},
          {name: "Electron", lifetime: 150},
          {name: "Anti-Electron Neutrino", lifetime: 100}
        ];
      }
      if (name === "Charm Quark") {
        return [
          {name: "Strange Quark", lifetime: 150},
          {name: "Positron", lifetime: 150},
          {name: "Electron Neutrino", lifetime: 100}
        ];
      }
      if (name === "Bottom Quark") {
        return [
          {name: "Charm Quark", lifetime: 200},
          {name: "Electron", lifetime: 150},
          {name: "Anti-Electron Neutrino", lifetime: 100}
        ];
      }
      if (name === "Top Quark") {
        return [
          {name: "Bottom Quark", lifetime: 50},
          {name: "Positron", lifetime: 50},
          {name: "Electron Neutrino", lifetime: 50}
        ];
      }
      // Leptons
      if (name === "Muon") {
        return [
          {name: "Electron", lifetime: 200},
          {name: "Electron Neutrino", lifetime: 100},
          {name: "Anti-Muon Neutrino", lifetime: 100}
        ];
      }
      if (name === "Anti-Muon") {
        return [
          {name: "Positron", lifetime: 200},
          {name: "Anti-Electron Neutrino", lifetime: 100},
          {name: "Muon Neutrino", lifetime: 100}
        ];
      }
      if (name === "Tau") {
        const rand = Math.random();
        if (rand < 0.5) {
          return [
            {name: "Muon", lifetime: 100},
            {name: "Muon Neutrino", lifetime: 80},
            {name: "Anti-Tau Neutrino", lifetime: 80}
          ];
        } else {
          return [
            {name: "Electron", lifetime: 100},
            {name: "Electron Neutrino", lifetime: 80},
            {name: "Anti-Tau Neutrino", lifetime: 80}
          ];
        }
      }
      if (name === "Anti-Tau") {
        const rand = Math.random();
        if (rand < 0.5) {
          return [
            {name: "Anti-Muon", lifetime: 100},
            {name: "Anti-Muon Neutrino", lifetime: 80},
            {name: "Tau Neutrino", lifetime: 80}
          ];
        } else {
          return [
            {name: "Positron", lifetime: 100},
            {name: "Anti-Electron Neutrino", lifetime: 80},
            {name: "Tau Neutrino", lifetime: 80}
          ];
        }
      }
      // Bosons
      if (name === "W Boson") {
        return [
          {name: "Positron", lifetime: 50},
          {name: "Electron Neutrino", lifetime: 50}
        ];
      }
      if (name === "Anti-W Boson") {
        return [
          {name: "Electron", lifetime: 50},
          {name: "Anti-Electron Neutrino", lifetime: 50}
        ];
      }
      if (name === "Z Boson") {
        const rand = Math.random();
        if (rand < 0.33) {
          return [
            {name: "Electron", lifetime: 50},
            {name: "Positron", lifetime: 50}
          ];
        } else if (rand < 0.66) {
          return [
            {name: "Muon", lifetime: 50},
            {name: "Anti-Muon", lifetime: 50}
          ];
        } else {
          return [
            {name: "Up Quark", lifetime: 50},
            {name: "Anti-Up Quark", lifetime: 50}
          ];
        }
      }
      if (name === "Higgs Boson") {
        const rand = Math.random();
        if (rand < 0.25) {
          return [
            {name: "Bottom Quark", lifetime: 100},
            {name: "Anti-Bottom Quark", lifetime: 100}
          ];
        } else if (rand < 0.5) {
          return [
            {name: "W Boson", lifetime: 100},
            {name: "Anti-W Boson", lifetime: 100}
          ];
        } else if (rand < 0.75) {
          return [
            {name: "Tau", lifetime: 100},
            {name: "Anti-Tau", lifetime: 100}
          ];
        } else {
          return [
            {name: "Z Boson", lifetime: 100},
            {name: "Z Boson", lifetime: 100}
          ];
        }
      }
      // Composite particles
      if (name === "Proton" || name === "Anti-Proton") {
        // Proton decay: 2-4 particles
        const count = 2 + Math.floor(Math.random() * 3);
        const products = [];
        for (let i = 0; i < count; i++) {
          const rand = Math.random();
          if (rand < 0.3) {
            products.push({name: "Pion", lifetime: 150});
          } else if (rand < 0.5) {
            products.push({name: "Charged Pion", lifetime: 150});
          } else if (rand < 0.7) {
            products.push({name: "Muon", lifetime: 200});
          } else if (rand < 0.9) {
            products.push({name: "Electron Neutrino", lifetime: 100});
          } else {
            products.push({name: "Photon", lifetime: 50});
          }
        }
        return products;
      }
      if ((name === "Electron" && particle.beam === "left") && 
          (particles.find(p => p.name === "Positron" && p.beam === "right" && !p.decayed))) {
        // Electron + Positron annihilation
        return [
          {name: "Photon", lifetime: 30},
          {name: "Photon", lifetime: 30}
        ];
      }
      if ((name === "Positron" && particle.beam === "right") && 
          (particles.find(p => p.name === "Electron" && p.beam === "left" && !p.decayed))) {
        // Electron + Positron annihilation
        return [
          {name: "Photon", lifetime: 30},
          {name: "Photon", lifetime: 30}
        ];
      }
      // Default decay
      return [
        {name: "Photon", lifetime: 50}
      ];
    }
    function detectCollisions() {
      if (particles.length < 2) return;
      // Check for collisions between left and right beam particles
      for (let i = 0; i < particles.length; i++) {
        const p1 = particles[i];
        if (p1.decayed || p1.beam !== "left") continue;
        for (let j = 0; j < particles.length; j++) {
          const p2 = particles[j];
          if (p2.decayed || p2.beam !== "right") continue;
          // Check if particles are close enough to collide
          const dx = p1.x - p2.x;
          const dy = p1.y - p2.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          // Collision occurs when particles are within a certain distance
          if (dist < 20) {
            // Determine collision flash color based on particle types
            let flashColor = {r: 255, g: 255, b: 200}; // Default white-yellow
            // Quark collisions
            if (p1.name.includes("Quark") && p2.name.includes("Quark")) {
              flashColor = {r: 255, g: 100, b: 100}; // Red spark
            } 
            // Lepton collisions
            else if ((p1.name === "Electron" && p2.name === "Positron") || 
                      (p1.name === "Positron" && p2.name === "Electron")) {
              flashColor = {r: 200, g: 230, b: 255}; // White-blue
            } else if (p1.name.includes("Muon") || p2.name.includes("Muon")) {
              flashColor = {r: 150, g: 255, b: 150}; // Soft green
            } else if (p1.name.includes("Tau") || p2.name.includes("Tau")) {
              flashColor = {r: 200, g: 100, b: 255}; // Violet
            }
            // Boson collisions
            else if (p1.name.includes("W") || p2.name.includes("W")) {
              flashColor = {r: 255, g: 255, b: 0}; // Yellow
            } else if (p1.name.includes("Z") || p2.name.includes("Z")) {
              flashColor = {r: 100, g: 255, b: 100}; // Green
            } else if (p1.name.includes("Higgs") || p2.name.includes("Higgs")) {
              flashColor = {r: 255, g: 200, b: 220}; // Pink
            }
            // Proton/Neutron collisions
            else if ((p1.name === "Proton" && p2.name === "Anti-Proton") || 
                     (p1.name === "Anti-Proton" && p2.name === "Proton")) {
              flashColor = {r: 255, g: 165, b: 0}; // Orange-yellow
            }
            // Create collision flash
            collisions.push({
              x: (p1.x + p2.x) / 2,
              y: (p1.y + p2.y) / 2,
              r: 15,
              time: Date.now(),
              color: flashColor
            });
            // Record collision time for rate calculation
            collisionTimes.push(Date.now());
            // Start decay sequences for both particles
            startDecaySequence(p1);
            startDecaySequence(p2);
            // Increment collision counter
            collisionCounter++;
          }
        }
      }
    }
    function drawSimpleBarChart(containerId, data, labels) {
      const container = document.getElementById(containerId);
      if (!container) return;
      container.innerHTML = ''; // Clear previous content
      if (data.length === 0 || labels.length === 0) return;
      const maxWidth = container.clientWidth;
      const maxHeight = container.clientHeight;
      const barSpacing = 10;
      const maxBarWidth = (maxWidth - (labels.length + 1) * barSpacing) / labels.length;
      const barWidth = Math.min(maxBarWidth, 30); // Cap bar width
      const maxValue = Math.max(...data, 1); // Avoid division by zero
      // Create SVG namespace for elements
      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("width", "100%");
      svg.setAttribute("height", "100%");
      svg.setAttribute("viewBox", `0 0 ${maxWidth} ${maxHeight}`);
      const startY = maxHeight - 20; // Base line for bars, leaving space for labels
      labels.forEach((label, i) => {
        const value = data[i];
        const barHeight = (value / maxValue) * (maxHeight - 30); // Leave space for labels
        const group = document.createElementNS(svgNS, "g");
        group.setAttribute("transform", `translate(${barSpacing + i * (barWidth + barSpacing)}, 0)`);
        // Bar
        const rect = document.createElementNS(svgNS, "rect");
        rect.setAttribute("x", "0");
        rect.setAttribute("y", `${startY - barHeight}`);
        rect.setAttribute("width", barWidth);
        rect.setAttribute("height", barHeight);
        rect.setAttribute("fill", `hsl(${i * 360 / labels.length}, 70%, 60%)`); // Color based on index
        group.appendChild(rect);
        // Label (truncated if too long)
        const textLabel = document.createElementNS(svgNS, "text");
        textLabel.setAttribute("x", barWidth / 2);
        textLabel.setAttribute("y", `${startY + 5}`);
        textLabel.setAttribute("text-anchor", "middle");
        textLabel.setAttribute("font-size", "8");
        textLabel.setAttribute("fill", "white");
        const displayLabel = label.length > 8 ? label.substring(0, 8) + "..." : label;
        textLabel.textContent = displayLabel;
        group.appendChild(textLabel);
        // Value
        const textValue = document.createElementNS(svgNS, "text");
        textValue.setAttribute("x", barWidth / 2);
        textValue.setAttribute("y", `${startY - barHeight - 5}`);
        textValue.setAttribute("text-anchor", "middle");
        textValue.setAttribute("font-size", "8");
        textValue.setAttribute("fill", "white");
        textValue.textContent = value.toFixed(1);
        group.appendChild(textValue);
        svg.appendChild(group);
      });
      container.appendChild(svg);
    }
    function updateStatsData() {
      const now = Date.now();
      const elapsedSeconds = (now - lastStatsUpdate) / 1000;
      totalSimulationTime += elapsedSeconds;
      // Count particles by type and origin
      let typeCounts = {}; // Only declare once
      let protonCountVal = 0;
      let electronCountVal = 0;
      let photonCountVal = 0;
      let beamParticleCount = 0;
      let decayParticleCount = 0;
      let activeParticleCount = 0;
      let decayedParticleCount = 0;
      let maxDecayChainLength = 0;
      let totalParticleCount = 0;
      let speedSum = 0;
      let energySum = 0;
      let maxEnergyValue = 0;
      let minEnergyValue = Infinity;
      let maxEnergyParticle = "None";
      let minEnergyParticle = "None";
      let totalDistanceTraveled = 0;
      let beamEnergySum = 0;
      let decayEnergySum = 0;
      let beamParticleCountForEnergy = 0;
      let decayParticleCountForEnergy = 0;
      for (let p of particles) {
        if (!p.decayed) {
          activeParticleCount++;
          if (p.origin === "left" || p.origin === "right") beamParticleCount++;
          if (p.origin === "decay") decayParticleCount++;
          if (p.name === "Proton" || p.name === "Anti-Proton") protonCountVal++;
          if (p.name === "Electron" || p.name === "Positron") electronCountVal++;
          if (p.name === "Photon") photonCountVal++;
          // Track type breakdown
          typeCounts[p.name] = (typeCounts[p.name] || 0) + 1;
          // Track max decay chain length
          if (p.decayChainLength > maxDecayChainLength) {
            maxDecayChainLength = p.decayChainLength;
          }
          // Calculate speed and energy
          const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
          const mass = getMassValue(p.name);
          const energy = 0.5 * mass * speed * speed;
          speedSum += speed;
          energySum += energy;
          totalDistanceTraveled += (p.distanceTraveled || 0);
          // Track maximum and minimum energy particles
          if (energy > maxEnergyValue) {
            maxEnergyValue = energy;
            maxEnergyParticle = p.name;
          }
          if (energy < minEnergyValue) {
            minEnergyValue = energy;
            minEnergyParticle = p.name;
          }
          // Track energy by origin
          if (p.origin === "left" || p.origin === "right") {
            beamEnergySum += energy;
            beamParticleCountForEnergy++;
          } else {
            decayEnergySum += energy;
            decayParticleCountForEnergy++;
          }
        } else {
          decayedParticleCount++;
        }
        // Count decay products
        if (p.decayProducts) {
          for (let dp of p.decayProducts) {
            if (dp.lifetime > 0) {
              totalParticleCount++;
              activeParticleCount++;
              decayParticleCount++;
              totalDistanceTraveled += (dp.distanceTraveled || 0);
              if (dp.name === "Proton" || dp.name === "Anti-Proton") protonCountVal++;
              if (dp.name === "Electron" || dp.name === "Positron") electronCountVal++;
              if (dp.name === "Photon") photonCountVal++;
              // Track type breakdown
              typeCounts[dp.name] = (typeCounts[dp.name] || 0) + 1;
              // Track max decay chain length
              if (dp.decayChainLength > maxDecayChainLength) {
                maxDecayChainLength = dp.decayChainLength;
              }
              // Calculate speed and energy
              const speed = Math.sqrt(dp.vx * dp.vx + dp.vy * dp.vy);
              const mass = getMassValue(dp.name);
              const energy = 0.5 * mass * speed * speed;
              speedSum += speed;
              energySum += energy;
              // Track maximum and minimum energy particles
              if (energy > maxEnergyValue) {
                maxEnergyValue = energy;
                maxEnergyParticle = dp.name;
              }
              if (energy < minEnergyValue && energy > 0) {
                minEnergyValue = energy;
                minEnergyParticle = dp.name;
              }
              // Track energy by origin
              decayEnergySum += energy;
              decayParticleCountForEnergy++;
            } else {
              decayedParticleCount++;
            }
          }
        }
      }
      totalParticleCount = activeParticleCount + decayedParticleCount;
      // Calculate type breakdown percentages
      let typeBreakdownText = "";
      if (activeParticleCount > 0) {
        // Sort types by count
        const sortedTypes = Object.entries(typeCounts).sort((a, b) => b[1] - a[1]);
        // Get top 3 types
        const topTypes = sortedTypes.slice(0, 3);
        const otherCount = activeParticleCount - topTypes.reduce((sum, [, count]) => sum + count, 0);
        // Format breakdown
        const breakdownParts = topTypes.map(([type, count]) => {
          const percentage = Math.round((count / activeParticleCount) * 100);
          // Shorten long names
          const shortName = type.length > 10 ? type.substring(0, 10) + "..." : type;
          return `${shortName} ${percentage}%`;
        });
        if (otherCount > 0) {
          const otherPercentage = Math.round((otherCount / activeParticleCount) * 100);
          breakdownParts.push(`Others ${otherPercentage}%`);
        }
        typeBreakdownText = breakdownParts.join(", ");
      } else {
        typeBreakdownText = "None";
      }
      // Find most common decay
      let decayCounts = {};
      for (let decay of decayLog) {
        decayCounts[decay.decayString] = (decayCounts[decay.decayString] || 0) + 1;
      }
      let mostCommonDecay = "None";
      let maxCount = 0;
      for (let decay in decayCounts) {
        if (decayCounts[decay] > maxCount) {
          maxCount = decayCounts[decay];
          mostCommonDecay = decay;
        }
      }
      // Calculate collision rate (collisions per second, last 5 seconds)
      const fiveSecondsAgo = now - 5000;
      collisionTimes = collisionTimes.filter(time => time > fiveSecondsAgo);
      const collisionRateValue = elapsedSeconds > 0 ? collisionTimes.length / 5 : 0;
      // Calculate decay rate (decays per second)
      const decayRateValue = totalSimulationTime > 0 ? decayCounter / totalSimulationTime : 0;
      // Calculate average lifetime of decayed particles
      let avgLifetimeValue = 0;
      if (particleLifetimes.length > 0) {
        const sum = particleLifetimes.reduce((a, b) => a + b, 0);
        avgLifetimeValue = sum / particleLifetimes.length;
      }
      // Calculate average distance traveled
      const avgDistanceTraveled = totalParticleCount > 0 ? totalDistanceTraveled / totalParticleCount : 0;
      // Calculate average energy by origin
      const avgBeamEnergy = beamParticleCountForEnergy > 0 ? beamEnergySum / beamParticleCountForEnergy : 0;
      const avgDecayEnergy = decayParticleCountForEnergy > 0 ? decayEnergySum / decayParticleCountForEnergy : 0;
      // Store data for charts and tables
      const currentTime = totalSimulationTime; // Time in seconds since simulation start
      statsData.totalParticles.push({time: currentTime, value: totalParticleCount});
      statsData.activeDecayed.push({time: currentTime, active: activeParticleCount, decayed: decayedParticleCount});
      statsData.beamParticles.push({time: currentTime, value: beamParticleCount});
      statsData.decayParticles.push({time: currentTime, value: decayParticleCount});
      statsData.maxDecayChain.push({time: currentTime, value: maxDecayChainLength});
      statsData.avgSpeed.push({time: currentTime, value: totalParticleCount > 0 ? (speedSum / totalParticleCount) : 0});
      statsData.avgEnergy.push({time: currentTime, value: totalParticleCount > 0 ? (energySum / totalParticleCount) : 0});
      statsData.maxEnergy.push({time: currentTime, value: maxEnergyValue, particle: maxEnergyParticle});
      statsData.minEnergy.push({time: currentTime, value: minEnergyValue === Infinity ? 0 : minEnergyValue, particle: minEnergyParticle});
      statsData.totalDistance.push({time: currentTime, value: totalDistanceTraveled});
      statsData.avgDistance.push({time: currentTime, value: avgDistanceTraveled});
      statsData.avgLifetime.push({time: currentTime, value: avgLifetimeValue});
      statsData.collisions.push({time: currentTime, count: collisionCounter, rate: collisionRateValue});
      statsData.decays.push({time: currentTime, count: decayCounter, rate: decayRateValue});
      statsData.beamEnergy.push({time: currentTime, value: avgBeamEnergy});
      statsData.decayEnergy.push({time: currentTime, value: avgDecayEnergy});
      // Update stats display
      totalParticles.textContent = totalParticleCount;
      activeDecayed.textContent = `${activeParticleCount} / ${decayedParticleCount}`;
      beamParticles.textContent = beamParticleCount;
      decayParticles.textContent = decayParticleCount;
      maxDecayChain.textContent = maxDecayChainLength;
      // Update composition table
      compositionTable.innerHTML = '';
      if (Object.keys(typeCounts).length > 0) {
        const sortedTypes = Object.entries(typeCounts).sort((a, b) => b[1] - a[1]);
        sortedTypes.forEach(([type, count]) => {
          const percentage = Math.round((count / activeParticleCount) * 100);
          const row = document.createElement('tr');
          row.innerHTML = `<td>${type}</td><td>${count}</td><td>${percentage}%</td>`;
          compositionTable.appendChild(row);
        });
      } else {
        const row = document.createElement('tr');
        row.innerHTML = '<td colspan="3">No data</td>';
        compositionTable.appendChild(row);
      }
      collisionCount.textContent = collisionCounter;
      collisionRate.textContent = collisionRateValue.toFixed(1);
      decayCount.textContent = decayCounter;
      decayRate.textContent = decayRateValue.toFixed(2);
      avgLifetime.textContent = avgLifetimeValue.toFixed(2);
      topDecays.textContent = mostCommonDecay;
      if (totalParticleCount > 0) {
        avgSpeed.textContent = (speedSum / totalParticleCount).toFixed(2);
        avgEnergy.textContent = (energySum / totalParticleCount).toFixed(2);
        totalDistance.textContent = totalDistanceTraveled.toFixed(2);
        avgDistance.textContent = avgDistanceTraveled.toFixed(2);
        beamEnergy.textContent = avgBeamEnergy.toFixed(2);
        decayEnergy.textContent = avgDecayEnergy.toFixed(2);
      } else {
        avgSpeed.textContent = "0.00";
        avgEnergy.textContent = "0.00";
        totalDistance.textContent = "0.00";
        avgDistance.textContent = "0.00";
        beamEnergy.textContent = "0.00";
        decayEnergy.textContent = "0.00";
      }
      if (maxEnergyValue > 0) {
        maxEnergy.textContent = `${maxEnergyValue.toFixed(1)} (${maxEnergyParticle})`;
      } else {
        maxEnergy.textContent = "0.00 (None)";
      }
      if (minEnergyValue !== Infinity && minEnergyValue > 0) {
        minEnergy.textContent = `${minEnergyValue.toFixed(1)} (${minEnergyParticle})`;
      } else {
        minEnergy.textContent = "0.00 (None)";
      }
      lastStatsUpdate = now;
        // BUG FIX: Commented out calls to drawSimpleBarChart for non-existent elements.
        // The `updateChart` function already handles drawing line charts in the correct containers.
        if (Object.keys(typeCounts).length > 0) {
          const sortedTypesForChart = Object.entries(typeCounts).sort((a, b) => b[1] - a[1]).slice(0, 5);
          const chartLabels = sortedTypesForChart.map(([type]) => type);
          const chartData = sortedTypesForChart.map(([, count]) => count);
          drawSimpleBarChart('compositionChart', chartData, chartLabels);
        }
        // drawSimpleBarChart('energyChart', [avgBeamEnergy, avgDecayEnergy], ['Beam Avg', 'Decay Avg']);
        // drawSimpleBarChart('distanceChart', [totalDistanceTraveled, avgDistanceTraveled], ['Total Dist', 'Avg Dist']);
        // drawSimpleBarChart('eventChart', [collisionCounter, decayCounter], ['Collisions', 'Decays']);
        // drawSimpleBarChart('energySplitChart', [avgBeamEnergy, avgDecayEnergy], ['Beam Energy', 'Decay Energy']);
    }
    function updateStats() {
      updateStatsData();
      // Update all tables with latest data
      updateTable('totalParticles', statsData.totalParticles, ['time', 'value']);
      updateTable('activeDecayed', statsData.activeDecayed, ['time', 'active', 'decayed']);
      updateTable('beamParticles', statsData.beamParticles, ['time', 'value']);
      updateTable('decayParticles', statsData.decayParticles, ['time', 'value']);
      updateTable('maxDecayChain', statsData.maxDecayChain, ['time', 'value']);
      updateTable('avgSpeed', statsData.avgSpeed, ['time', 'value']);
      updateTable('avgEnergy', statsData.avgEnergy, ['time', 'value']);
      updateTable('maxEnergy', statsData.maxEnergy, ['time', 'value', 'particle']);
      updateTable('minEnergy', statsData.minEnergy, ['time', 'value', 'particle']);
      updateTable('totalDistance', statsData.totalDistance, ['time', 'value']);
      updateTable('avgDistance', statsData.avgDistance, ['time', 'value']);
      updateTable('avgLifetime', statsData.avgLifetime, ['time', 'value']);
      updateTable('collisions', statsData.collisions, ['time', 'count', 'rate']);
      updateTable('decays', statsData.decays, ['time', 'count', 'rate']);
      updateTable('beamEnergy', statsData.beamEnergy, ['time', 'value']);
      updateTable('decayEnergy', statsData.decayEnergy, ['time', 'value']);
      // Update all charts
      updateChart('totalParticles', statsData.totalParticles, 'value');
      updateChart('activeDecayed', statsData.activeDecayed, ['active', 'decayed']);
      updateChart('beamParticles', statsData.beamParticles, 'value');
      updateChart('decayParticles', statsData.decayParticles, 'value');
      updateChart('maxDecayChain', statsData.maxDecayChain, 'value');
      updateChart('avgSpeed', statsData.avgSpeed, 'value');
      updateChart('avgEnergy', statsData.avgEnergy, 'value');
      updateChart('maxEnergy', statsData.maxEnergy, 'value');
      updateChart('minEnergy', statsData.minEnergy, 'value');
      updateChart('totalDistance', statsData.totalDistance, 'value');
      updateChart('avgDistance', statsData.avgDistance, 'value');
      updateChart('avgLifetime', statsData.avgLifetime, 'value');
      updateChart('collisions', statsData.collisions, 'count');
      updateChart('decays', statsData.decays, 'count');
      updateChart('beamEnergy', statsData.beamEnergy, 'value');
      updateChart('decayEnergy', statsData.decayEnergy, 'value');
    }
    function updateTable(section, data, columns) {
      const tableBody = document.getElementById(`${section}TableBody`);
      if (!tableBody) return;
      
      tableBody.innerHTML = '';
      data.slice(-10).forEach(item => { // Show last 10 entries
        const row = document.createElement('tr');
        columns.forEach(col => {
          const cell = document.createElement('td');
          cell.textContent = typeof item[col] === 'number' ? item[col].toFixed(2) : item[col];
          row.appendChild(cell);
        });
        tableBody.appendChild(row);
      });
    }
    function updateChart(section, data, valueKey) {
      const chartContainer = document.getElementById(`${section}Chart`);
      if (!chartContainer) return;
      
      // Clear previous chart
      chartContainer.innerHTML = '';
      
      if (data.length === 0) return;
      
      // Create canvas for chart
      const canvas = document.createElement('canvas');
      canvas.width = chartContainer.clientWidth;
      canvas.height = chartContainer.clientHeight;
      chartContainer.appendChild(canvas);
      
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Extract values
      let values;
      if (Array.isArray(valueKey)) {
        // For multi-value charts (like active/decayed)
        values = valueKey.map(key => data.map(item => item[key]));
      } else {
        // For single-value charts
        values = [data.map(item => item[valueKey])];
      }
      
      // Find min and max values
      let allValues = [];
      values.forEach(arr => allValues = allValues.concat(arr));
      const minVal = Math.min(...allValues);
      const maxVal = Math.max(...allValues);
      const range = maxVal - minVal || 1; // Avoid division by zero
      
      // Find min and max times
      const times = data.map(item => item.time);
      const minTime = Math.min(...times);
      const maxTime = Math.max(...times);
      const timeRange = maxTime - minTime || 1; // Avoid division by zero
      
      // Draw chart
      const padding = 20;
      const chartWidth = width - 2 * padding;
      const chartHeight = height - 2 * padding;
      
      // Draw grid
      ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
      ctx.beginPath();
      for (let i = 0; i <= 5; i++) {
        const y = padding + chartHeight - (i / 5) * chartHeight;
        ctx.moveTo(padding, y);
        ctx.lineTo(padding + chartWidth, y);
      }
      ctx.stroke();
      
      // Draw axes
      ctx.strokeStyle = 'rgba(200, 200, 200, 0.7)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, padding + chartHeight);
      ctx.lineTo(padding + chartWidth, padding + chartHeight);
      ctx.stroke();
      
      // Draw data lines
      const colors = [
        '#4dabf7', // Blue
        '#ff6b6b', // Red
        '#51cf66', // Green
        '#fcc419', // Yellow
        '#cc5de8'  // Purple
      ];
      
      values.forEach((valueArray, idx) => {
        if (valueArray.length < 2) return;
        
        ctx.strokeStyle = colors[idx % colors.length];
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        const pointSpacing = chartWidth / (valueArray.length - 1);
        valueArray.forEach((val, i) => {
          const x = padding + ((times[i] - minTime) / timeRange) * chartWidth;
          const y = padding + chartHeight - ((val - minVal) / range) * chartHeight;
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        
        ctx.stroke();
      });
      
      // Draw labels
      ctx.fillStyle = 'white';
      ctx.font = '8px Arial';
      ctx.textAlign = 'center';
      
      // Y-axis labels
      ctx.textAlign = 'right';
      for (let i = 0; i <= 5; i++) {
        const val = minVal + (i / 5) * range;
        const y = padding + chartHeight - (i / 5) * chartHeight;
        ctx.fillText(val.toFixed(1), padding - 5, y + 3);
      }
    }
    function loop() {
      if (!running && particles.length === 0 && collisions.length === 0) {
        animationId = null; // Stop the loop if there's nothing to do
        return;
      }
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if(running) {
        updateParticles();
      }
      drawParticles();
      // Update stats if enabled
      if (statsCheckbox.checked) {
        updateStats();
      }
      animationId = requestAnimationFrame(loop);
    }
    function startSpawning() {
      if (spawnIntervalId) clearInterval(spawnIntervalId);
      spawnIntervalId = setInterval(createParticles, spawnInterval / timeScale);
    }
    function stopSpawning() {
      if (spawnIntervalId) {
        clearInterval(spawnIntervalId);
        spawnIntervalId = null;
      }
    }
    playPauseBtn.addEventListener("click", () => {
      running = !running;
      if (running) {
        playPauseBtn.textContent = "⏸️";
        if (!animationId) {
          // Restart the loop if it was stopped
          animationId = requestAnimationFrame(loop);
        }
        startSpawning();
      } else {
        playPauseBtn.textContent = "▶️";
        stopSpawning();
      }
    });
    resetBtn.addEventListener("click", () => {
      running = false;
      playPauseBtn.textContent = "▶️";
      stopSpawning();
      particles.length = 0;
      collisions.length = 0;
      collisionCounter = 0;
      decayCounter = 0;
      decayLog = [];
      collisionTimes = [];
      particleLifetimes = [];
      energyLostToDecay = 0;
      recentDecayChain = "None";
      totalSimulationTime = 0;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Don't cancel animation frame here, let the loop stop itself
      
      // Reset stats data
      Object.keys(statsData).forEach(key => {
        statsData[key] = [];
      });
      // Clear stats display
      updateStats();
    });
    oneParticleBtn.addEventListener("click", () => {
      createSingleParticlePair();
       // Make sure the loop is running to draw the new particles
      if (!animationId) {
        animationId = requestAnimationFrame(loop);
      }
    });
    // Instructions modal
    instructionsBtn.addEventListener('click', () => {
      instructionsModal.classList.add('show');
    });
    closeInstructions.addEventListener('click', () => {
      instructionsModal.classList.remove('show');
    });
    // Stats toggle - now works as a proper toggle
   statsToggle.addEventListener('click', () => {
      statsCheckbox.checked = !statsCheckbox.checked;
      if (statsCheckbox.checked) {
        statsDisplay.classList.add('show');
        // Collapse all stat sections when opening stats
        document.querySelectorAll('.stat-section-title').forEach(title => {
          title.classList.add('collapsed');
          title.nextElementSibling.classList.add('collapsed');
        });
        // --- Close floating graph if it's open ---
        if (floatingGraphWindow.classList.contains('show')) {
            closeFloatingGraphWindow();
        }
      } else {
        statsDisplay.classList.remove('show');
      }
    });
    // Add accordion functionality to stats sections
    document.querySelectorAll('.stat-section-title').forEach(title => {
      title.addEventListener('click', () => {
        const content = title.nextElementSibling;
        title.classList.toggle('collapsed');
        content.classList.toggle('collapsed');
      });
    });
    
    // --- Floating Graph Window Logic ---
    const floatingGraphWindow = document.getElementById('floatingGraphWindow');
    let currentFloatingGraphMetric = null;
    let floatingGraphUpdateIntervalId = null; // For 1-second updates
    const floatingGraphHeader = document.getElementById('floatingGraphHeader'); // For dragging
    const floatingGraphTitle = document.getElementById('floatingGraphTitle');
    const floatingGraphCanvasContainer = document.getElementById('floatingGraphCanvasContainer');
    const closeFloatingGraphBtn = document.getElementById('closeFloatingGraph');
    
    const friendlyNames = {
        'totalParticles': 'Total Particles',
        'activeDecayed': 'Active / Decayed Particles',
        'beamParticles': 'Particles from Beams',
        'decayParticles': 'Particles from Decays',
        'maxDecayChain': 'Maximum Decay Chain Length',
        'avgSpeed': 'Average Speed',
        'avgEnergy': 'Average Energy',
        'maxEnergy': 'Maximum Energy',
        'minEnergy': 'Minimum Energy',
        'totalDistance': 'Total Distance Traveled',
        'avgDistance': 'Average Distance Traveled',
        'avgLifetime': 'Average Lifetime',
        'collisions': 'Collisions',
        'decays': 'Decays',
        'beamEnergy': 'Average Beam Energy',
        'decayEnergy': 'Average Decay Energy'
    };
    
    // --- Draggable Window Logic (Consolidated and Corrected) ---
    let isDragging = false;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    function startDrag(e) {
        if (e.target === floatingGraphHeader || e.target === floatingGraphTitle) {
            isDragging = true;
            const rect = floatingGraphWindow.getBoundingClientRect();
            dragOffsetX = e.clientX - rect.left;
            dragOffsetY = e.clientY - rect.top;
            
            // Convert position to fixed px so it doesn't jump on transform removal
            floatingGraphWindow.style.bottom = ''; // Remove bottom positioning
            floatingGraphWindow.style.transform = ''; // Remove transform
            floatingGraphWindow.style.left = `${rect.left}px`;
            floatingGraphWindow.style.top = `${rect.top}px`;
            
            document.body.style.cursor = 'move';
            e.preventDefault();
        }
    }

    function drag(e) {
        if (isDragging) {
            const newX = e.clientX - dragOffsetX;
            const newY = e.clientY - dragOffsetY;
            floatingGraphWindow.style.left = `${newX}px`;
            floatingGraphWindow.style.top = `${newY}px`;
        }
    }

    function stopDrag() {
        isDragging = false;
        document.body.style.cursor = '';
    }

    function attachDragListeners() {
        floatingGraphHeader.addEventListener('mousedown', startDrag);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', stopDrag);
    }

    function detachDragListeners() {
        floatingGraphHeader.removeEventListener('mousedown', startDrag);
        document.removeEventListener('mousemove', drag);
        document.removeEventListener('mouseup', stopDrag);
        isDragging = false; // Ensure state is reset
        document.body.style.cursor = '';
    }

    // --- Floating Graph Window Functions (Corrected and Simplified) ---
    function showFloatingGraphWindow(metricKey) {
        if (!floatingGraphWindow || !metricKey) return;
        
        currentFloatingGraphMetric = metricKey;
        floatingGraphTitle.textContent = friendlyNames[metricKey] || `Graph: ${metricKey}`;

        // If window is not positioned, place it near center-bottom
        if (!floatingGraphWindow.style.left || floatingGraphWindow.style.left === '50%') {
            const centerX = (window.innerWidth - floatingGraphWindow.offsetWidth) / 2;
            const bottomY = window.innerHeight - floatingGraphWindow.offsetHeight - 20;
            floatingGraphWindow.style.left = `${Math.max(centerX, 20)}px`;
            floatingGraphWindow.style.top = `${Math.max(bottomY, -20)}px`;
            floatingGraphWindow.style.bottom = '';
            floatingGraphWindow.style.transform = '';
        }
        
        floatingGraphWindow.classList.add('show');
        drawFloatingChart(metricKey);

        if (floatingGraphUpdateIntervalId) {
            clearInterval(floatingGraphUpdateIntervalId);
        }
        floatingGraphUpdateIntervalId = setInterval(() => {
            if (floatingGraphWindow.classList.contains('show') && currentFloatingGraphMetric) {
                drawFloatingChart(currentFloatingGraphMetric);
            }
        }, 1000);

        attachDragListeners();
    }

    function closeFloatingGraphWindow() {
        if (!floatingGraphWindow) return;
        floatingGraphWindow.classList.remove('show');
        currentFloatingGraphMetric = null;
        floatingGraphCanvasContainer.innerHTML = '';
        
        if (floatingGraphUpdateIntervalId) {
            clearInterval(floatingGraphUpdateIntervalId);
            floatingGraphUpdateIntervalId = null;
        }

        detachDragListeners();

        // Reset to initial CSS position
        floatingGraphWindow.style.left = '50%';
        floatingGraphWindow.style.top = '';
        floatingGraphWindow.style.bottom = '20px';
        floatingGraphWindow.style.transform = 'translateX(-50%)';
    }
    
    closeFloatingGraphBtn.addEventListener('click', closeFloatingGraphWindow);
    
    // --- Event Listeners for View Toggling (Consolidated) ---
    document.addEventListener('click', function(event) {
        const graphBtn = event.target.closest('.graph-btn');
        const tableBtn = event.target.closest('.table-btn');

        if (graphBtn) {
            const metricKey = graphBtn.getAttribute('data-metric');
            if (currentFloatingGraphMetric === metricKey && floatingGraphWindow.classList.contains('show')) {
                closeFloatingGraphWindow();
            } else {
                showFloatingGraphWindow(metricKey);
                if (statsDisplay.classList.contains('show')) {
                    statsCheckbox.checked = false;
                    statsDisplay.classList.remove('show');
                }
            }
        }
        
        if (tableBtn) {
            const metricKey = tableBtn.getAttribute('data-metric');
            const chartView = document.getElementById(`${metricKey}Chart`);
            const tableView = document.getElementById(`${metricKey}Table`);
            
            // Toggle views within the stats panel
            if (chartView) chartView.classList.add('hidden');
            if (tableView) tableView.classList.add('show');

            // Update button active state
            tableBtn.parentElement.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
            tableBtn.classList.add('active');
        }
    });

    // --- Implement drawFloatingChart function ---
    function drawFloatingChart(metricKey) {
        const data = statsData[metricKey];
        if (!data || data.length === 0) {
            floatingGraphCanvasContainer.innerHTML = '<div style="color:white; text-align:center; padding-top:90px;">No data yet...</div>';
            return;
        }

        floatingGraphCanvasContainer.innerHTML = '';
        const canvas = document.createElement('canvas');
        floatingGraphCanvasContainer.appendChild(canvas);
        const ctx = canvas.getContext('2d');
        const containerWidth = floatingGraphCanvasContainer.clientWidth;
        const containerHeight = floatingGraphCanvasContainer.clientHeight;
        canvas.width = containerWidth;
        canvas.height = containerHeight;

        let valueKeys = [];
        if (metricKey === 'activeDecayed') valueKeys = ['active', 'decayed'];
        else if (metricKey === 'collisions' || metricKey === 'decays') valueKeys = ['count'];
        else valueKeys = ['value'];

        const times = data.map(d => d.time);
        const datasets = valueKeys.map(key => ({
            values: data.map(d => d[key] !== undefined ? d[key] : d.value),
            key: key
        }));

        let allValues = [];
        datasets.forEach(ds => allValues = allValues.concat(ds.values));
        const minValue = (allValues.length > 0) ? Math.min(...allValues) : 0;
        const maxValue = (allValues.length > 0) ? Math.max(...allValues) : 1;
        const valueRange = (maxValue - minValue) || 1;
        const minTime = (times.length > 0) ? Math.min(...times) : 0;
        const maxTime = (times.length > 0) ? Math.max(...times) : 1;
        const timeRange = (maxTime - minTime) || 1;

        const padding = 40;
        const chartWidth = containerWidth - 2 * padding;
        const chartHeight = containerHeight - 2 * padding;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, containerWidth, containerHeight);
        ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 0; i <= 5; i++) {
            const y = padding + chartHeight - (i / 5) * chartHeight;
            ctx.moveTo(padding, y);
            ctx.lineTo(padding + chartWidth, y);
        }
        ctx.stroke();

        ctx.strokeStyle = 'rgba(200, 200, 200, 0.7)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, padding + chartHeight);
        ctx.lineTo(padding + chartWidth, padding + chartHeight);
        ctx.stroke();

        const colors = ['#4dabf7', '#ff6b6b', '#51cf66', '#fcc419', '#cc5de8'];
        datasets.forEach((dataset, dsIdx) => {
            if (dataset.values.length < 2) return;
            const color = colors[dsIdx % colors.length];
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            dataset.values.forEach((val, i) => {
                const x = padding + ((times[i] - minTime) / timeRange) * chartWidth;
                const y = padding + chartHeight - ((val - minValue) / valueRange) * chartHeight;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
        });

        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        for (let i = 0; i <= 5; i++) {
            const val = minValue + (i / 5) * valueRange;
            const y = padding + chartHeight - (i / 5) * chartHeight;
            ctx.fillText(val.toFixed(1), padding - 10, y);
        }

        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        const labelStep = Math.max(1, Math.floor(times.length / 5));
        for (let i = 0; i < times.length; i += labelStep) {
            const time = times[i];
            const x = padding + ((time - minTime) / timeRange) * chartWidth;
            ctx.fillText(time.toFixed(1) + 's', x, padding + chartHeight + 5);
        }

        if (datasets.length > 1) {
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            datasets.forEach((ds, idx) => {
                const y = padding + 10 + idx * 15;
                const color = colors[idx % colors.length];
                ctx.fillStyle = color;
                ctx.fillRect(padding + 10, y, 10, 10);
                ctx.fillStyle = 'white';
                ctx.fillText(ds.key, padding + 25, y);
            });
        }
    }
    
    // --- Particle Selection Modal Logic ---
    const leftParticleBtn = document.getElementById('leftParticleBtn');
    const rightParticleBtn = document.getElementById('rightParticleBtn');
    const particleModal = document.getElementById('particleModal');
    const beamSideLabel = document.getElementById('beamSideLabel');
    const normalParticlesContainer = document.getElementById('normalParticles');
    const antiParticlesContainer = document.getElementById('antiParticles');
    const closeModalBtn = document.getElementById('closeParticleModal');
    let selectingSide = 'left';
    let selectedParticles = {
      left: { name: 'Proton', color: '#ff6b6b' },
      right: { name: 'Anti-Proton', color: '#b33a3a' }
    };
    function updateParticlePreviews() {
      leftParticlePreview.style.backgroundColor = selectedParticles.left.color;
      rightParticlePreview.style.backgroundColor = selectedParticles.right.color;
      leftParticleName.textContent = selectedParticles.left.name;
      rightParticleName.textContent = selectedParticles.right.name;
      const leftProps = getParticleProperties(selectedParticles.left.name);
      leftParticleMass.textContent = `Mass: ${leftProps.mass}`;
      leftParticleCharge.textContent = `Charge: ${leftProps.charge}`;
      leftParticleLifetime.textContent = `Lifetime: ${leftProps.lifetime}`;
      const rightProps = getParticleProperties(selectedParticles.right.name);
      rightParticleMass.textContent = `Mass: ${rightProps.mass}`;
      rightParticleCharge.textContent = `Charge: ${rightProps.charge}`;
      rightParticleLifetime.textContent = `Lifetime: ${rightProps.lifetime}`;
    }
    updateParticlePreviews();
    const standardModelParticles = [
      { name: 'Up Quark', color: '#ff6666' }, { name: 'Down Quark', color: '#ff9966' },
      { name: 'Strange Quark', color: '#ccff66' }, { name: 'Charm Quark', color: '#66ff66' },
      { name: 'Bottom Quark', color: '#6666ff' }, { name: 'Top Quark', color: '#cc66ff' },
      { name: 'Electron', color: '#4dabf7' }, { name: 'Muon', color: '#51cf66' },
      { name: 'Tau', color: '#cc5de8' }, { name: 'Electron Neutrino', color: '#a0d2ff' },
      { name: 'Photon', color: '#ffffff' }, { name: 'W Boson', color: '#ffff00' },
      { name: 'Z Boson', color: '#66ff66' }, { name: 'Higgs Boson', color: '#ffccdd' },
      { name: 'Proton', color: '#ff6b6b' }, { name: 'Neutron', color: '#ffff99' }
    ];
    function populateParticleGrid(grid, particles) {
      grid.innerHTML = '';
      particles.forEach(p => {
        const btn = document.createElement('button');
        btn.className = 'particle-button';
        const colorDot = document.createElement('span');
        colorDot.className = 'particle-color';
        colorDot.style.backgroundColor = p.color;
        const name = document.createElement('span');
        name.className = 'particle-name';
        name.textContent = p.name;
        btn.appendChild(colorDot);
        btn.appendChild(name);
        btn.addEventListener('click', () => {
          selectedParticles[selectingSide] = { name: p.name, color: p.color };
          updateParticlePreviews();
          particleModal.classList.remove('show');
        });
        grid.appendChild(btn);
      });
    }
    leftParticleBtn.addEventListener('click', () => {
      if (particleModal.classList.contains('show') && selectingSide === 'left') {
        particleModal.classList.remove('show');
        return;
      }
      selectingSide = 'left';
      beamSideLabel.textContent = 'left';
      populateParticleGrid(normalParticlesContainer, standardModelParticles);
      populateParticleGrid(antiParticlesContainer, standardModelParticles.map(p => ({
        name: 'Anti-' + p.name,
        color: invertColor(p.color)
      })));
      particleModal.classList.add('show');
    });
    rightParticleBtn.addEventListener('click', () => {
      if (particleModal.classList.contains('show') && selectingSide === 'right') {
        particleModal.classList.remove('show');
        return;
      }
      selectingSide = 'right';
      beamSideLabel.textContent = 'right';
      populateParticleGrid(normalParticlesContainer, standardModelParticles);
      populateParticleGrid(antiParticlesContainer, standardModelParticles.map(p => ({
        name: 'Anti-' + p.name,
        color: invertColor(p.color)
      })));
      particleModal.classList.add('show');
    });
    closeModalBtn.addEventListener('click', () => {
      particleModal.classList.remove('show');
    });
    particleModal.addEventListener('click', (e) => {
      if (e.target === particleModal) {
        particleModal.classList.remove('show');
      }
    });
    function invertColor(hex) {
      if (!hex.startsWith('#')) return hex;
      let c = hex.substring(1);
      if (c.length === 3) c = c[0]+c[0]+c[1]+c[1]+c[2]+c[2];
      let num = parseInt(c, 16);
      let r = 255 - ((num >> 16) & 255);
      let g = 255 - ((num >> 8) & 255);
      let b = 255 - (num & 255);
      return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).padStart(6, '0');
    }
    
    // BUG FIX: The animation loop should not start automatically on page load.
    // It is now correctly started only when the user presses the play button.
    // The initial call to requestAnimationFrame(loop) has been removed from the end of the script.
    
    // Start with a single frame draw to show the initial empty state.
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawParticles();

  });
  </script>
</body>
</html>
