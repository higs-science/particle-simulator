<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>2D Particle Collider</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
      color: white;
    }
    
    canvas {
      display: block;
      background: #111;
    }
  
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 10px;
    }
  
    button {
      padding: 10px 20px;
      font-size: 16px;
    }
  
    #zoomSlider {
      vertical-align: middle;
    }
  
    label {
      display: flex;
      align-items: center;
      gap: 8px;
      color: white;
      margin-left: 20px;
      user-select: none;
    }
  
    #particleModal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #000;
      border: 2px solid white;
      border-radius: 10px;
      padding: 20px;
      display: none;
      z-index: 20;
      color: white;
    }
  
    #particleModal.show {
      display: block;
    }

    .grid-label {
      font-family: Arial, sans-serif;
    }
    
    .particle-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 10px;
      margin: 10px 0;
    }
  
    .particle-button {
      padding: 8px;
      text-align: center;
      border: 1px solid white;
      border-radius: 5px;
      cursor: pointer;
      background: #000;
    }
    
    .particle-button:focus {
      outline: 2px solid white;
    }
  
    .particle-button:hover {
      background: #555;
    }
  </style>
</head>
<body>
  <div id="controls">
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
    <button id="resetBtn">Reset</button>
    <button id="fireOnePairBtn">Fire 1 Left + 1 Right</button>

    <label for="zoomSlider">
      Zoom:
      <input id="zoomSlider" type="range" min="1" max="100" step="1" value="100" />
      <span id="zoomLabel">100%</span>
    </label>

    <label for="timeScaleInput">
      Time Scale:
      <input id="timeScaleInput" type="number" min="0.01" max="10" step="0.1" value="1" />
    </label>

    <label for="particleCountInput">
      Particle Count:
      <input id="particleCountInput" type="range" min="1" max="100" step="1" value="10" />
      <span id="particleCountLabel">10</span>
    </label>

    <div id="particleControls">
      <button id="leftParticleBtn">Left Particle</button>
      <button id="rightParticleBtn">Right Particle</button>
    </div>
  </div>

  <div id="particleModal">
    <div id="particleModalContent">
      <h2>Select Particle Type</h2>
      <p>Choose a particle for the <span id="beamSideLabel">left</span> beam:</p>

      <div class="grid-label">Standard Model</div>
      <div class="particle-grid" id="normalParticles"></div>

      <div class="grid-label">Antimatter Counterparts</div>
      <div class="particle-grid" id="antiParticles"></div>

      <button id="closeParticleModal">Close</button>
    </div>
  </div>

  <canvas id="sim"></canvas>

  <script>
  window.addEventListener("DOMContentLoaded", () => {
    const canvas = document.getElementById("sim");
    const ctx = canvas.getContext("2d");
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const resetBtn = document.getElementById("resetBtn");
    const zoomSlider = document.getElementById("zoomSlider");
    const zoomLabel = document.querySelector("#controls span#zoomLabel");
    const timeScaleInput = document.getElementById("timeScaleInput");
    const particleCountInput = document.getElementById("particleCountInput");
    const particleCountLabel = document.getElementById("particleCountLabel");

    let timeScale = 1;
    let batchSize = parseInt(particleCountInput.value);

    particleCountInput.addEventListener("input", () => {
      batchSize = parseInt(particleCountInput.value);
      particleCountLabel.textContent = batchSize;
    });

    timeScaleInput.addEventListener("input", () => {
      timeScale = parseFloat(timeScaleInput.value) || 1;
    });

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    window.particles = [];
    const particles = window.particles;
    window.collisions = [];
    let collisions = window.collisions;
    let animationId = null;
    let running = false;

    const bandTop = () => canvas.height * 0.25;
    const bandBottom = () => canvas.height * 0.75;
    const spawnInterval = 500;

    // Zoom variables
    let zoomLevel = 1; // scale factor (1 = normal)
    let zoomCenter = { x: canvas.width / 2, y: canvas.height / 2 };

    // Initialize zoom slider and label
    zoomLabel.textContent = zoomSlider.value + "%";

    zoomSlider.addEventListener("input", () => {
      const val = parseInt(zoomSlider.value);
      zoomLabel.textContent = val + "%";
      // Map slider 1..100 to zoomLevel 100..1 (inverted)
      zoomLevel = 101 - val;
      if (zoomLevel < 1) zoomLevel = 1;
      if (zoomLevel > 100) zoomLevel = 100;
    });

    function createParticles() {
      const baseRadius = 6;
      const scaledRadius = baseRadius * (10 / batchSize); // Fewer particles = bigger radius

      for (let i = 0; i < batchSize; i++) {
        // LEFT beam particles start near left edge, moving right
        particles.push({
          x: scaledRadius + Math.random() * 30, // near left edge + some randomness
          y: bandTop() + Math.random() * (bandBottom() - bandTop()),
          r: scaledRadius,
          vx: 5 + Math.random() * 2,
          vy: (Math.random() - 0.5) * 0.5,
          beam: "left",
          color: selectedParticles.left.color,
          name: selectedParticles.left.name || "Proton",
          lifetime: 50,
          decayed: false,
          falling: false,
          fallSpeed: 0
        });

        // RIGHT beam particles start near right edge, moving left
        particles.push({
          x: canvas.width - scaledRadius - Math.random() * 30, // near right edge - some randomness
          y: bandTop() + Math.random() * (bandBottom() - bandTop()),
          r: scaledRadius,
          vx: -5 - Math.random() * 2,
          vy: (Math.random() - 0.5) * 0.5,
          beam: "right",
          color: selectedParticles.right.color,
          name: selectedParticles.right.name || "Proton",
          lifetime: 1000,
          decayed: false,
          falling: false,
          fallSpeed: 0
        });
      }
    }

    function drawParticles() {
      for (let p of particles) {
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 10;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // **Removed labels here â€” no text drawn**
      }
    
      // ðŸŸ¡ Draw collision flashes
      const now = Date.now();
      for (let i = collisions.length - 1; i >= 0; i--) {
        const c = collisions[i];
        const elapsed = now - c.time;
        const duration = 300 / timeScale;
        if (elapsed > duration) {
          collisions.splice(i, 1);
          continue;
        }
        const alpha = 1 - elapsed / duration;
        ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.r * 2 * alpha, 0, Math.PI * 2);
        ctx.fill();
      }
    
      collisions = collisions.filter(c => Date.now() - c.time < 200);
    }

    function updateParticles() {
      for (let p of particles) {
        if (Math.abs(p.vx) < 0.1 && !p.falling) {
          p.vx = (Math.random() - 0.5) * 2;
        }

        if (!p.falling) {
          p.x += p.vx * timeScale;
          p.y += p.vy * timeScale;

          // Bounce vertically inside the band limits ONLY if NOT falling
          if (p.y < bandTop() + p.r || p.y > bandBottom() - p.r) {
            p.vy *= -1;
          }
        } else {
          // Falling particle logic: move down steadily off screen
          p.x += 0; // no horizontal move on fall, can adjust if you want drift
          p.y += p.fallSpeed * timeScale;
          p.fallSpeed += 0.1 * timeScale;

          // Slowly reduce velocity on fall (optional)
          p.vx *= 0.95;
          p.vy *= 0.95;
        }

        if (p.lifetime !== undefined && p.lifetime > 0) {
          p.lifetime -= timeScale;
          if (p.lifetime < 0) p.lifetime = 0;
        }
      }

      // Remove decayed particles once fully off screen (below or off sides)
      window.particles = window.particles.filter(p => {
        if (!p.decayed) return true;
        return (
          p.x + p.r > 0 &&
          p.x - p.r < canvas.width &&
          p.y - p.r < canvas.height
        );
      });

      detectCollisions();
    }

    // Helper: map particle names to colors
    function getColorForParticle(name) {
      const colorMap = {
        'Electron': '#00f',
        'Positron': '#0ff',
        'Muon': '#0ff',
        'Anti-Electron': '#0f0',
        'Photon': '#fff',
        'Neutrino': '#ccc',
        'Proton': '#f00',
        'Anti-Proton': '#c00',
        // Add more particles/colors as needed for your decay chains
      };
      return colorMap[name];
    }

    // Decay sequence using Monte Carlo decay chain, applying colors
    function startDecaySequence(particle) {
      if (particle.decayed) return;  // Prevent multiple decay sequences
      particle.decayed = true;

      const originX = particle.x;
      const originY = particle.y;

      particle.falling = false;
      particle.vx = (Math.random() - 0.5) * 6; // explode out
      particle.vy = (Math.random() - 0.5) * 6;


      const decayChain = window.simulateDecayChain(particle);

      let index = 0;

      function showNextDecay() {
        if (index >= decayChain.length) return;

        const decayParticle = decayChain[index];

        decayParticle.x = originX + (Math.random() - 0.5) * 30;
        decayParticle.y = originY + (Math.random() - 0.5) * 30;
        decayParticle.r = particle.r * 0.7;
        decayParticle.lifetime = 500;
        decayParticle.decayed = false;
        decayParticle.falling = false;
        decayParticle.fallSpeed = 0;

        decayParticle.color = getColorForParticle(decayParticle.name) || '#fff';

        const angle = Math.random() * 2 * Math.PI;
        const speed = 2 + Math.random() * 2;
        decayParticle.vx = Math.cos(angle) * speed;
        decayParticle.vy = Math.sin(angle) * speed;

        particles.push(decayParticle);

        index++;
        setTimeout(showNextDecay, 1000);
      }

      showNextDecay();
    }

    function detectCollisions() {
      const normalCollisionChance = 1e-2;
    
      for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
          const a = particles[i];
          const b = particles[j];
    
          if (a.beam === b.beam) continue;
    
          const dx = a.x - b.x;
          const dy = a.y - b.y;
          const distSq = dx * dx + dy * dy;
          const radiusSum = a.r + b.r;
    
          if (distSq < radiusSum * radiusSum) {
            // Determine collision chance
            let collisionChance = normalCollisionChance;
            if (a.guaranteedCollision && b.guaranteedCollision) {
              collisionChance = 1; // 100% collision chance
            }
    
            if (Math.random() < collisionChance) {
              collisions.push({
                x: (a.x + b.x) / 2,
                y: (a.y + b.y) / 2,
                r: (a.r + b.r) / 2,
                time: Date.now()
              });
    
              if (!a.decayed) startDecaySequence(a);
              if (!b.decayed) startDecaySequence(b);
            }
          }
        }
      }
    }


    function loop() {
      if (!running) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Update zoom center based on zoom level
      if (zoomLevel > 10 && particles.length >= 2) {
        const p1 = particles[0];
        const p2 = particles[1];
        zoomCenter.x = (p1.x + p2.x) / 2;
        zoomCenter.y = (p1.y + p2.y) / 2;
      } else {
        zoomCenter.x = canvas.width / 2;
        zoomCenter.y = canvas.height / 2;
      }

      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.scale(zoomLevel, zoomLevel);
      ctx.translate(-zoomCenter.x, -zoomCenter.y);

      updateParticles();
      drawParticles();

      ctx.restore();

      animationId = requestAnimationFrame(loop);
    }

    function startSpawning() {
      function spawnLoop() {
        if (!running) return;
        createParticles();
        setTimeout(spawnLoop, spawnInterval / timeScale);
      }
      spawnLoop();
    }

    function stopSpawning() {
      // no interval timers to clear; recursive setTimeout only
    }    

    startBtn.addEventListener("click", () => {
      if (!running) {
        running = true;
        createParticles();
        loop();
        startSpawning();
      }
    });

    stopBtn.addEventListener("click", () => {
      running = false;
      stopSpawning();
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    });

    resetBtn.addEventListener("click", () => {
      running = false;
      stopSpawning();
      particles.length = 0;
      collisions.length = 0;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    });

    const leftParticleBtn = document.getElementById('leftParticleBtn');
    const rightParticleBtn = document.getElementById('rightParticleBtn');
    const particleModal = document.getElementById('particleModal');
    const beamSideLabel = document.getElementById('beamSideLabel');
    const normalParticlesContainer = document.getElementById('normalParticles');
    const antiParticlesContainer = document.getElementById('antiParticles');
    const closeModalBtn = document.getElementById('closeParticleModal');
    const fireOnePairBtn = document.getElementById('fireOnePairBtn');

    let selectingSide = 'left';

    let selectedParticles = {
      left: { name: 'Electron', color: '#00f' },
      right: { name: 'Anti-Electron', color: '#0f0' }
    };

    const standardModelParticles = [
      { name: 'Electron', color: '#00f' },
      { name: 'Muon', color: '#0ff' },
      { name: 'Tau', color: '#08f' },
      { name: 'Up Quark', color: '#f00' },
      { name: 'Down Quark', color: '#fa0' },
      { name: 'Strange Quark', color: '#ff0' },
      { name: 'Charm Quark', color: '#0f0' },
      { name: 'Bottom Quark', color: '#0a0' },
      { name: 'Top Quark', color: '#800' },
      { name: 'Photon', color: '#fff' },
      { name: 'Z Boson', color: '#ccc' },
      { name: 'W Boson', color: '#999' }
    ];

    function populateParticleGrid(grid, particles) {
      grid.innerHTML = '';
      particles.forEach(p => {
        const btn = document.createElement('button');
        btn.className = 'particle-button';
        btn.style.backgroundColor = '#000';

        const circle = document.createElement('span');
        circle.style.display = 'inline-block';
        circle.style.width = '16px';
        circle.style.height = '16px';
        circle.style.borderRadius = '50%';
        circle.style.backgroundColor = p.color;
        circle.style.marginRight = '8px';
        circle.style.verticalAlign = 'middle';

        const text = document.createElement('span');
        text.textContent = p.name;
        text.style.color = 'white';
        text.style.fontFamily = 'Arial, sans-serif';
        text.style.fontSize = '14px';

        btn.appendChild(circle);
        btn.appendChild(text);

        btn.addEventListener('click', () => {
          selectedParticles[selectingSide] = { name: p.name, color: p.color };
          particleModal.classList.remove('show');
        });

        grid.appendChild(btn);
      });
    }

    leftParticleBtn.addEventListener('click', () => {
      selectingSide = 'left';
      beamSideLabel.textContent = 'left';
      populateParticleGrid(normalParticlesContainer, standardModelParticles);
      populateParticleGrid(antiParticlesContainer, standardModelParticles.map(p => ({
        name: 'Anti-' + p.name,
        color: invertColor(p.color)
      })));
      particleModal.classList.add('show');
    });

    rightParticleBtn.addEventListener('click', () => {
      selectingSide = 'right';
      beamSideLabel.textContent = 'right';
      populateParticleGrid(normalParticlesContainer, standardModelParticles);
      populateParticleGrid(antiParticlesContainer, standardModelParticles.map(p => ({
        name: 'Anti-' + p.name,
        color: invertColor(p.color)
      })));
      particleModal.classList.add('show');
    });

    closeModalBtn.addEventListener('click', () => {
      particleModal.classList.remove('show');
    });

    fireOnePairBtn.addEventListener("click", () => {
      const baseRadius = 6;
      const scaledRadius = baseRadius;
    
      // Left particle
      particles.push({
        x: scaledRadius + 10,
        y: canvas.height / 2,
        r: scaledRadius,
        vx: 6,
        vy: 0,
        beam: "left",
        color: selectedParticles.left.color,
        name: selectedParticles.left.name || "Proton",
        lifetime: 100,
        decayed: false,
        falling: false,
        fallSpeed: 0,
        guaranteedCollision: true  // <--- flag added
      });
    
      // Right particle
      particles.push({
        x: canvas.width - scaledRadius - 10,
        y: canvas.height / 2,
        r: scaledRadius,
        vx: -6,
        vy: 0,
        beam: "right",
        color: selectedParticles.right.color,
        name: selectedParticles.right.name || "Proton",
        lifetime: 100,
        decayed: false,
        falling: false,
        fallSpeed: 0,
        guaranteedCollision: true  // <--- flag added
      });
    
      if (!running) {
        running = true;
        loop();
      }
    });





    // Utility to invert hex color, for antimatter
    function invertColor(hex) {
      if (!hex.startsWith('#')) return hex;
      let c = hex.substring(1);
      if (c.length === 3) {
        c = c[0]+c[0]+c[1]+c[1]+c[2]+c[2];
      }
      let num = parseInt(c, 16);
      let r = 255 - ((num >> 16) & 255);
      let g = 255 - ((num >> 8) & 255);
      let b = 255 - (num & 255);
      return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    // Dummy Monte Carlo decay chain function (replace with your real function)
    window.simulateDecayChain = function(particle) {
      // Return a chain of decay particles, example:
      if (particle.name.toLowerCase().includes("electron")) {
        return [
          { name: "Photon", color: "#fff" },
          { name: "Positron", color: "#0ff" },
          { name: "Neutrino", color: "#ccc" }
        ];
      }
      if (particle.name.toLowerCase().includes("proton")) {
        return [
          { name: "Muon", color: "#0ff" },
          { name: "Neutrino", color: "#ccc" }
        ];
      }
      // Default decay chain
      return [
        { name: "Photon", color: "#fff" }
      ];
    };

  });
  </script>
</body>
</html>
