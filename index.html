<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>2D Particle Collider</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; }
    canvas { display: block; background: #111; }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
    }
    #zoomSlider {
      vertical-align: middle;
    }
    label {
      color: white;
      margin-left: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
      user-select: none;
    }
  </style>
</head>
<body>
<div id="controls">
  <button id="startBtn">Start</button>
  <button id="stopBtn">Stop</button>
  <button id="resetBtn">Reset</button>

  <label for="zoomSlider">
    Zoom:
    <input id="zoomSlider" type="range" min="1" max="100" step="1" value="100" />
    <span id="zoomLabel">100%</span>
  </label>

  <label for="timeScaleInput">
    Time Scale:
    <input id="timeScaleInput" type="number" min="0.01" max="10" step="0.1" value="1" />
  </label>

</div>

<canvas id="sim"></canvas>

<script>
window.addEventListener("DOMContentLoaded", () => {
  const canvas = document.getElementById("sim");
  const ctx = canvas.getContext("2d");
  const startBtn = document.getElementById("startBtn");
  const stopBtn = document.getElementById("stopBtn");
  const resetBtn = document.getElementById("resetBtn");
  const zoomSlider = document.getElementById("zoomSlider");
  const zoomLabel = document.querySelector("#controls span#zoomLabel");
  const timeScaleInput = document.getElementById("timeScaleInput");
  let timeScale = 1;

  timeScaleInput.addEventListener("input", () => {
    timeScale = parseFloat(timeScaleInput.value) || 1;
  });

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resizeCanvas();
  window.addEventListener("resize", resizeCanvas);

  let particles = [];
  let collisions = [];
  let animationId = null;
  let running = false;
  const timeScaleInput = document.getElementById("timeScaleInput");
  let timeScale = 1;

  timeScaleInput.addEventListener("input", () => {
    timeScale = parseFloat(timeScaleInput.value) || 1;
  });

  const bandTop = () => canvas.height * 0.25;
  const bandBottom = () => canvas.height * 0.75;
  const batchSize = 10;
  const spawnInterval = 500;
  let spawnTimer = null;

  // Zoom variables
  let zoomLevel = 1; // scale factor (1 = normal)
  let zoomCenter = { x: canvas.width / 2, y: canvas.height / 2 };

  // Initialize zoom slider and label
  zoomLabel.textContent = zoomSlider.value + "%";

  zoomSlider.addEventListener("input", () => {
    const val = parseInt(zoomSlider.value);
    zoomLabel.textContent = val + "%";
    // Map slider 1..100 to zoomLevel 100..1 (inverted)
    zoomLevel = 101 - val;
    if (zoomLevel < 1) zoomLevel = 1;
    if (zoomLevel > 100) zoomLevel = 100;
  });

  function createParticles() {
    for (let i = 0; i < batchSize; i++) {
      particles.push({
        x: Math.random() * 100,
        y: bandTop() + Math.random() * (bandBottom() - bandTop()),
        r: 3,
        vx: 5 + Math.random() * 2,
        vy: (Math.random() - 0.5) * 0.5,
        beam: "right"
      });
      particles.push({
        x: canvas.width - Math.random() * 100,
        y: bandTop() + Math.random() * (bandBottom() - bandTop()),
        r: 3,
        vx: -5 - Math.random() * 2,
        vy: (Math.random() - 0.5) * 0.5,
        beam: "left"
      });
    }
  }

  function drawParticles() {
    ctx.fillStyle = "red";
    for (let p of particles) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
    }

    // Draw collision flashes
    const now = Date.now();
    for (let i = collisions.length - 1; i >= 0; i--) {
      const c = collisions[i];
      const elapsed = now - c.time;
      const duration = 300 / timescale;
      if (elapsed > duration) {
        collisions.splice(i, 1);
        continue;
      }
      const alpha = 1 - elapsed / duration;
      ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
      ctx.beginPath();
      ctx.arc(c.x, c.y, 30 * alpha, 0, Math.PI * 2);
      ctx.fill();
    }

    // Fade collisions after short time
    collisions = collisions.filter(c => Date.now() - c.time < 200);
  }

  function updateParticles() {
    for (let p of particles) {
      p.x += p.vx * timescale;
      p.y += p.vy * timescale;
      if (p.y < bandTop() + p.r || p.y > bandBottom() - p.r) {
        p.vy *= -1;
      }
    }

    particles = particles.filter(p => p.x + p.r > 0 && p.x - p.r < canvas.width);

    detectCollisions();
  }

  function detectCollisions() {
    const collisionChance = 1e-2; // Adjust this to match desired frequency

    for (let i = 0; i < particles.length; i++) {
      for (let j = i + 1; j < particles.length; j++) {
        const a = particles[i];
        const b = particles[j];

        // Only check opposite-direction beams
        if (a.beam === b.beam) continue;

        const dx = a.x - b.x;
        const dy = a.y - b.y;
        const distSq = dx * dx + dy * dy;
        const radiusSum = a.r + b.r;

        if (distSq < radiusSum * radiusSum) {
          if (Math.random() < collisionChance) {
            collisions.push({ x: (a.x + b.x) / 2, y: (a.y + b.y) / 2, time: Date.now() });
          }
        }
      }
    }
  }

  function loop() {
    if (!running) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Update zoom center based on zoom level
    if (zoomLevel > 10 && particles.length >= 2) {
      // Zoomed in: center between first two particles
      const p1 = particles[0];
      const p2 = particles[1];
      zoomCenter.x = (p1.x + p2.x) / 2;
      zoomCenter.y = (p1.y + p2.y) / 2;
    } else {
      // Zoomed out: center on canvas center
      zoomCenter.x = canvas.width / 2;
      zoomCenter.y = canvas.height / 2;
    }

    ctx.save();
    // Translate to center of canvas
    ctx.translate(canvas.width / 2, canvas.height / 2);
    // Scale for zoom
    ctx.scale(zoomLevel, zoomLevel);
    // Translate zoom center to origin
    ctx.translate(-zoomCenter.x, -zoomCenter.y);

    updateParticles();
    drawParticles();

    ctx.restore();

    animationId = requestAnimationFrame(loop);
  }

  function startSpawning() {
    spawnTimer = setInterval(() => {
      if (running) createParticles();
    }, spawnInterval);
  }

  function stopSpawning() {
    clearInterval(spawnTimer);
    spawnTimer = null;
  }

  startBtn.addEventListener("click", () => {
    if (!running) {
      running = true;
      createParticles();
      loop();
      startSpawning();
    }
  });

  stopBtn.addEventListener("click", () => {
    running = false;
    stopSpawning();
    if (animationId) {
      cancelAnimationFrame(animationId);
      animationId = null;
    }
  });

  resetBtn.addEventListener("click", () => {
    running = false;
    stopSpawning();
    particles = [];
    collisions = [];
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (animationId) {
      cancelAnimationFrame(animationId);
      animationId = null;
    }
  });
});
</script>
</body>
</html>
